// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: krpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_krpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_krpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_krpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_krpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_krpc_2eproto;
namespace krpc {
namespace schema {
class Argument;
class ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class Class;
class ClassDefaultTypeInternal;
extern ClassDefaultTypeInternal _Class_default_instance_;
class ConnectionRequest;
class ConnectionRequestDefaultTypeInternal;
extern ConnectionRequestDefaultTypeInternal _ConnectionRequest_default_instance_;
class ConnectionResponse;
class ConnectionResponseDefaultTypeInternal;
extern ConnectionResponseDefaultTypeInternal _ConnectionResponse_default_instance_;
class Dictionary;
class DictionaryDefaultTypeInternal;
extern DictionaryDefaultTypeInternal _Dictionary_default_instance_;
class DictionaryEntry;
class DictionaryEntryDefaultTypeInternal;
extern DictionaryEntryDefaultTypeInternal _DictionaryEntry_default_instance_;
class Enumeration;
class EnumerationDefaultTypeInternal;
extern EnumerationDefaultTypeInternal _Enumeration_default_instance_;
class EnumerationValue;
class EnumerationValueDefaultTypeInternal;
extern EnumerationValueDefaultTypeInternal _EnumerationValue_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Exception;
class ExceptionDefaultTypeInternal;
extern ExceptionDefaultTypeInternal _Exception_default_instance_;
class List;
class ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class MultiplexedRequest;
class MultiplexedRequestDefaultTypeInternal;
extern MultiplexedRequestDefaultTypeInternal _MultiplexedRequest_default_instance_;
class MultiplexedResponse;
class MultiplexedResponseDefaultTypeInternal;
extern MultiplexedResponseDefaultTypeInternal _MultiplexedResponse_default_instance_;
class Parameter;
class ParameterDefaultTypeInternal;
extern ParameterDefaultTypeInternal _Parameter_default_instance_;
class Procedure;
class ProcedureDefaultTypeInternal;
extern ProcedureDefaultTypeInternal _Procedure_default_instance_;
class ProcedureCall;
class ProcedureCallDefaultTypeInternal;
extern ProcedureCallDefaultTypeInternal _ProcedureCall_default_instance_;
class ProcedureResult;
class ProcedureResultDefaultTypeInternal;
extern ProcedureResultDefaultTypeInternal _ProcedureResult_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Service;
class ServiceDefaultTypeInternal;
extern ServiceDefaultTypeInternal _Service_default_instance_;
class Services;
class ServicesDefaultTypeInternal;
extern ServicesDefaultTypeInternal _Services_default_instance_;
class Set;
class SetDefaultTypeInternal;
extern SetDefaultTypeInternal _Set_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class StreamResult;
class StreamResultDefaultTypeInternal;
extern StreamResultDefaultTypeInternal _StreamResult_default_instance_;
class StreamUpdate;
class StreamUpdateDefaultTypeInternal;
extern StreamUpdateDefaultTypeInternal _StreamUpdate_default_instance_;
class Tuple;
class TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace schema
}  // namespace krpc
PROTOBUF_NAMESPACE_OPEN
template<> ::krpc::schema::Argument* Arena::CreateMaybeMessage<::krpc::schema::Argument>(Arena*);
template<> ::krpc::schema::Class* Arena::CreateMaybeMessage<::krpc::schema::Class>(Arena*);
template<> ::krpc::schema::ConnectionRequest* Arena::CreateMaybeMessage<::krpc::schema::ConnectionRequest>(Arena*);
template<> ::krpc::schema::ConnectionResponse* Arena::CreateMaybeMessage<::krpc::schema::ConnectionResponse>(Arena*);
template<> ::krpc::schema::Dictionary* Arena::CreateMaybeMessage<::krpc::schema::Dictionary>(Arena*);
template<> ::krpc::schema::DictionaryEntry* Arena::CreateMaybeMessage<::krpc::schema::DictionaryEntry>(Arena*);
template<> ::krpc::schema::Enumeration* Arena::CreateMaybeMessage<::krpc::schema::Enumeration>(Arena*);
template<> ::krpc::schema::EnumerationValue* Arena::CreateMaybeMessage<::krpc::schema::EnumerationValue>(Arena*);
template<> ::krpc::schema::Error* Arena::CreateMaybeMessage<::krpc::schema::Error>(Arena*);
template<> ::krpc::schema::Event* Arena::CreateMaybeMessage<::krpc::schema::Event>(Arena*);
template<> ::krpc::schema::Exception* Arena::CreateMaybeMessage<::krpc::schema::Exception>(Arena*);
template<> ::krpc::schema::List* Arena::CreateMaybeMessage<::krpc::schema::List>(Arena*);
template<> ::krpc::schema::MultiplexedRequest* Arena::CreateMaybeMessage<::krpc::schema::MultiplexedRequest>(Arena*);
template<> ::krpc::schema::MultiplexedResponse* Arena::CreateMaybeMessage<::krpc::schema::MultiplexedResponse>(Arena*);
template<> ::krpc::schema::Parameter* Arena::CreateMaybeMessage<::krpc::schema::Parameter>(Arena*);
template<> ::krpc::schema::Procedure* Arena::CreateMaybeMessage<::krpc::schema::Procedure>(Arena*);
template<> ::krpc::schema::ProcedureCall* Arena::CreateMaybeMessage<::krpc::schema::ProcedureCall>(Arena*);
template<> ::krpc::schema::ProcedureResult* Arena::CreateMaybeMessage<::krpc::schema::ProcedureResult>(Arena*);
template<> ::krpc::schema::Request* Arena::CreateMaybeMessage<::krpc::schema::Request>(Arena*);
template<> ::krpc::schema::Response* Arena::CreateMaybeMessage<::krpc::schema::Response>(Arena*);
template<> ::krpc::schema::Service* Arena::CreateMaybeMessage<::krpc::schema::Service>(Arena*);
template<> ::krpc::schema::Services* Arena::CreateMaybeMessage<::krpc::schema::Services>(Arena*);
template<> ::krpc::schema::Set* Arena::CreateMaybeMessage<::krpc::schema::Set>(Arena*);
template<> ::krpc::schema::Status* Arena::CreateMaybeMessage<::krpc::schema::Status>(Arena*);
template<> ::krpc::schema::Stream* Arena::CreateMaybeMessage<::krpc::schema::Stream>(Arena*);
template<> ::krpc::schema::StreamResult* Arena::CreateMaybeMessage<::krpc::schema::StreamResult>(Arena*);
template<> ::krpc::schema::StreamUpdate* Arena::CreateMaybeMessage<::krpc::schema::StreamUpdate>(Arena*);
template<> ::krpc::schema::Tuple* Arena::CreateMaybeMessage<::krpc::schema::Tuple>(Arena*);
template<> ::krpc::schema::Type* Arena::CreateMaybeMessage<::krpc::schema::Type>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace krpc {
namespace schema {

enum ConnectionRequest_Type : int {
  ConnectionRequest_Type_RPC = 0,
  ConnectionRequest_Type_STREAM = 1,
  ConnectionRequest_Type_ConnectionRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConnectionRequest_Type_ConnectionRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConnectionRequest_Type_IsValid(int value);
constexpr ConnectionRequest_Type ConnectionRequest_Type_Type_MIN = ConnectionRequest_Type_RPC;
constexpr ConnectionRequest_Type ConnectionRequest_Type_Type_MAX = ConnectionRequest_Type_STREAM;
constexpr int ConnectionRequest_Type_Type_ARRAYSIZE = ConnectionRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionRequest_Type_descriptor();
template<typename T>
inline const std::string& ConnectionRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionRequest_Type_descriptor(), enum_t_value);
}
inline bool ConnectionRequest_Type_Parse(
    const std::string& name, ConnectionRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionRequest_Type>(
    ConnectionRequest_Type_descriptor(), name, value);
}
enum ConnectionResponse_Status : int {
  ConnectionResponse_Status_OK = 0,
  ConnectionResponse_Status_MALFORMED_MESSAGE = 1,
  ConnectionResponse_Status_TIMEOUT = 2,
  ConnectionResponse_Status_WRONG_TYPE = 3,
  ConnectionResponse_Status_ConnectionResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConnectionResponse_Status_ConnectionResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConnectionResponse_Status_IsValid(int value);
constexpr ConnectionResponse_Status ConnectionResponse_Status_Status_MIN = ConnectionResponse_Status_OK;
constexpr ConnectionResponse_Status ConnectionResponse_Status_Status_MAX = ConnectionResponse_Status_WRONG_TYPE;
constexpr int ConnectionResponse_Status_Status_ARRAYSIZE = ConnectionResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConnectionResponse_Status_descriptor();
template<typename T>
inline const std::string& ConnectionResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConnectionResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConnectionResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConnectionResponse_Status_descriptor(), enum_t_value);
}
inline bool ConnectionResponse_Status_Parse(
    const std::string& name, ConnectionResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConnectionResponse_Status>(
    ConnectionResponse_Status_descriptor(), name, value);
}
enum Procedure_GameScene : int {
  Procedure_GameScene_SPACE_CENTER = 0,
  Procedure_GameScene_FLIGHT = 1,
  Procedure_GameScene_TRACKING_STATION = 2,
  Procedure_GameScene_EDITOR_VAB = 3,
  Procedure_GameScene_EDITOR_SPH = 4,
  Procedure_GameScene_MISSION_BUILDER = 5,
  Procedure_GameScene_Procedure_GameScene_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Procedure_GameScene_Procedure_GameScene_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Procedure_GameScene_IsValid(int value);
constexpr Procedure_GameScene Procedure_GameScene_GameScene_MIN = Procedure_GameScene_SPACE_CENTER;
constexpr Procedure_GameScene Procedure_GameScene_GameScene_MAX = Procedure_GameScene_MISSION_BUILDER;
constexpr int Procedure_GameScene_GameScene_ARRAYSIZE = Procedure_GameScene_GameScene_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Procedure_GameScene_descriptor();
template<typename T>
inline const std::string& Procedure_GameScene_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Procedure_GameScene>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Procedure_GameScene_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Procedure_GameScene_descriptor(), enum_t_value);
}
inline bool Procedure_GameScene_Parse(
    const std::string& name, Procedure_GameScene* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Procedure_GameScene>(
    Procedure_GameScene_descriptor(), name, value);
}
enum Type_TypeCode : int {
  Type_TypeCode_NONE = 0,
  Type_TypeCode_DOUBLE = 1,
  Type_TypeCode_FLOAT = 2,
  Type_TypeCode_SINT32 = 3,
  Type_TypeCode_SINT64 = 4,
  Type_TypeCode_UINT32 = 5,
  Type_TypeCode_UINT64 = 6,
  Type_TypeCode_BOOL = 7,
  Type_TypeCode_STRING = 8,
  Type_TypeCode_BYTES = 9,
  Type_TypeCode_CLASS = 100,
  Type_TypeCode_ENUMERATION = 101,
  Type_TypeCode_EVENT = 200,
  Type_TypeCode_PROCEDURE_CALL = 201,
  Type_TypeCode_STREAM = 202,
  Type_TypeCode_STATUS = 203,
  Type_TypeCode_SERVICES = 204,
  Type_TypeCode_TUPLE = 300,
  Type_TypeCode_LIST = 301,
  Type_TypeCode_SET = 302,
  Type_TypeCode_DICTIONARY = 303,
  Type_TypeCode_Type_TypeCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Type_TypeCode_Type_TypeCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Type_TypeCode_IsValid(int value);
constexpr Type_TypeCode Type_TypeCode_TypeCode_MIN = Type_TypeCode_NONE;
constexpr Type_TypeCode Type_TypeCode_TypeCode_MAX = Type_TypeCode_DICTIONARY;
constexpr int Type_TypeCode_TypeCode_ARRAYSIZE = Type_TypeCode_TypeCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_TypeCode_descriptor();
template<typename T>
inline const std::string& Type_TypeCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_TypeCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_TypeCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_TypeCode_descriptor(), enum_t_value);
}
inline bool Type_TypeCode_Parse(
    const std::string& name, Type_TypeCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_TypeCode>(
    Type_TypeCode_descriptor(), name, value);
}
// ===================================================================

class ConnectionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ConnectionRequest) */ {
 public:
  inline ConnectionRequest() : ConnectionRequest(nullptr) {};
  virtual ~ConnectionRequest();

  ConnectionRequest(const ConnectionRequest& from);
  ConnectionRequest(ConnectionRequest&& from) noexcept
    : ConnectionRequest() {
    *this = ::std::move(from);
  }

  inline ConnectionRequest& operator=(const ConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionRequest& operator=(ConnectionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequest*>(
               &_ConnectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConnectionRequest& a, ConnectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionRequest* New() const final {
    return CreateMaybeMessage<ConnectionRequest>(nullptr);
  }

  ConnectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionRequest& from);
  void MergeFrom(const ConnectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.ConnectionRequest";
  }
  protected:
  explicit ConnectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ConnectionRequest_Type Type;
  static constexpr Type RPC =
    ConnectionRequest_Type_RPC;
  static constexpr Type STREAM =
    ConnectionRequest_Type_STREAM;
  static inline bool Type_IsValid(int value) {
    return ConnectionRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ConnectionRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ConnectionRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ConnectionRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ConnectionRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ConnectionRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ConnectionRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientNameFieldNumber = 2,
    kClientIdentifierFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string client_name = 2;
  void clear_client_name();
  const std::string& client_name() const;
  void set_client_name(const std::string& value);
  void set_client_name(std::string&& value);
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  std::string* mutable_client_name();
  std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_client_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_client_name(
      std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // bytes client_identifier = 3;
  void clear_client_identifier();
  const std::string& client_identifier() const;
  void set_client_identifier(const std::string& value);
  void set_client_identifier(std::string&& value);
  void set_client_identifier(const char* value);
  void set_client_identifier(const void* value, size_t size);
  std::string* mutable_client_identifier();
  std::string* release_client_identifier();
  void set_allocated_client_identifier(std::string* client_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_client_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_client_identifier(
      std::string* client_identifier);
  private:
  const std::string& _internal_client_identifier() const;
  void _internal_set_client_identifier(const std::string& value);
  std::string* _internal_mutable_client_identifier();
  public:

  // .krpc.schema.ConnectionRequest.Type type = 1;
  void clear_type();
  ::krpc::schema::ConnectionRequest_Type type() const;
  void set_type(::krpc::schema::ConnectionRequest_Type value);
  private:
  ::krpc::schema::ConnectionRequest_Type _internal_type() const;
  void _internal_set_type(::krpc::schema::ConnectionRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.ConnectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identifier_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class ConnectionResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ConnectionResponse) */ {
 public:
  inline ConnectionResponse() : ConnectionResponse(nullptr) {};
  virtual ~ConnectionResponse();

  ConnectionResponse(const ConnectionResponse& from);
  ConnectionResponse(ConnectionResponse&& from) noexcept
    : ConnectionResponse() {
    *this = ::std::move(from);
  }

  inline ConnectionResponse& operator=(const ConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectionResponse& operator=(ConnectionResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectionResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectionResponse*>(
               &_ConnectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConnectionResponse& a, ConnectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectionResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectionResponse* New() const final {
    return CreateMaybeMessage<ConnectionResponse>(nullptr);
  }

  ConnectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectionResponse& from);
  void MergeFrom(const ConnectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.ConnectionResponse";
  }
  protected:
  explicit ConnectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ConnectionResponse_Status Status;
  static constexpr Status OK =
    ConnectionResponse_Status_OK;
  static constexpr Status MALFORMED_MESSAGE =
    ConnectionResponse_Status_MALFORMED_MESSAGE;
  static constexpr Status TIMEOUT =
    ConnectionResponse_Status_TIMEOUT;
  static constexpr Status WRONG_TYPE =
    ConnectionResponse_Status_WRONG_TYPE;
  static inline bool Status_IsValid(int value) {
    return ConnectionResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    ConnectionResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    ConnectionResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    ConnectionResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return ConnectionResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return ConnectionResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return ConnectionResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kClientIdentifierFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes client_identifier = 3;
  void clear_client_identifier();
  const std::string& client_identifier() const;
  void set_client_identifier(const std::string& value);
  void set_client_identifier(std::string&& value);
  void set_client_identifier(const char* value);
  void set_client_identifier(const void* value, size_t size);
  std::string* mutable_client_identifier();
  std::string* release_client_identifier();
  void set_allocated_client_identifier(std::string* client_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_client_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_client_identifier(
      std::string* client_identifier);
  private:
  const std::string& _internal_client_identifier() const;
  void _internal_set_client_identifier(const std::string& value);
  std::string* _internal_mutable_client_identifier();
  public:

  // .krpc.schema.ConnectionResponse.Status status = 1;
  void clear_status();
  ::krpc::schema::ConnectionResponse_Status status() const;
  void set_status(::krpc::schema::ConnectionResponse_Status value);
  private:
  ::krpc::schema::ConnectionResponse_Status _internal_status() const;
  void _internal_set_status(::krpc::schema::ConnectionResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.ConnectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_identifier_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Request) */ {
 public:
  inline Request() : Request(nullptr) {};
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallsFieldNumber = 1,
  };
  // repeated .krpc.schema.ProcedureCall calls = 1;
  int calls_size() const;
  private:
  int _internal_calls_size() const;
  public:
  void clear_calls();
  ::krpc::schema::ProcedureCall* mutable_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureCall >*
      mutable_calls();
  private:
  const ::krpc::schema::ProcedureCall& _internal_calls(int index) const;
  ::krpc::schema::ProcedureCall* _internal_add_calls();
  public:
  const ::krpc::schema::ProcedureCall& calls(int index) const;
  ::krpc::schema::ProcedureCall* add_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureCall >&
      calls() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureCall > calls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class ProcedureCall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ProcedureCall) */ {
 public:
  inline ProcedureCall() : ProcedureCall(nullptr) {};
  virtual ~ProcedureCall();

  ProcedureCall(const ProcedureCall& from);
  ProcedureCall(ProcedureCall&& from) noexcept
    : ProcedureCall() {
    *this = ::std::move(from);
  }

  inline ProcedureCall& operator=(const ProcedureCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcedureCall& operator=(ProcedureCall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcedureCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureCall* internal_default_instance() {
    return reinterpret_cast<const ProcedureCall*>(
               &_ProcedureCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ProcedureCall& a, ProcedureCall& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcedureCall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcedureCall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcedureCall* New() const final {
    return CreateMaybeMessage<ProcedureCall>(nullptr);
  }

  ProcedureCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcedureCall& from);
  void MergeFrom(const ProcedureCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.ProcedureCall";
  }
  protected:
  explicit ProcedureCall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kServiceFieldNumber = 1,
    kProcedureFieldNumber = 2,
    kServiceIdFieldNumber = 4,
    kProcedureIdFieldNumber = 5,
  };
  // repeated .krpc.schema.Argument arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::krpc::schema::Argument* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Argument >*
      mutable_arguments();
  private:
  const ::krpc::schema::Argument& _internal_arguments(int index) const;
  ::krpc::schema::Argument* _internal_add_arguments();
  public:
  const ::krpc::schema::Argument& arguments(int index) const;
  ::krpc::schema::Argument* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Argument >&
      arguments() const;

  // string service = 1;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_service();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_service(
      std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // string procedure = 2;
  void clear_procedure();
  const std::string& procedure() const;
  void set_procedure(const std::string& value);
  void set_procedure(std::string&& value);
  void set_procedure(const char* value);
  void set_procedure(const char* value, size_t size);
  std::string* mutable_procedure();
  std::string* release_procedure();
  void set_allocated_procedure(std::string* procedure);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_procedure();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_procedure(
      std::string* procedure);
  private:
  const std::string& _internal_procedure() const;
  void _internal_set_procedure(const std::string& value);
  std::string* _internal_mutable_procedure();
  public:

  // uint32 service_id = 4;
  void clear_service_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 service_id() const;
  void set_service_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_service_id() const;
  void _internal_set_service_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 procedure_id = 5;
  void clear_procedure_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 procedure_id() const;
  void set_procedure_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_procedure_id() const;
  void _internal_set_procedure_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.ProcedureCall)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Argument > arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr procedure_;
  ::PROTOBUF_NAMESPACE_ID::uint32 service_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 procedure_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Argument PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Argument) */ {
 public:
  inline Argument() : Argument(nullptr) {};
  virtual ~Argument();

  Argument(const Argument& from);
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Argument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const final {
    return CreateMaybeMessage<Argument>(nullptr);
  }

  Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Argument";
  }
  protected:
  explicit Argument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kPositionFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 position = 1;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::uint32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Argument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Response) */ {
 public:
  inline Response() : Response(nullptr) {};
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .krpc.schema.ProcedureResult results = 2;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::krpc::schema::ProcedureResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureResult >*
      mutable_results();
  private:
  const ::krpc::schema::ProcedureResult& _internal_results(int index) const;
  ::krpc::schema::ProcedureResult* _internal_add_results();
  public:
  const ::krpc::schema::ProcedureResult& results(int index) const;
  ::krpc::schema::ProcedureResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureResult >&
      results() const;

  // .krpc.schema.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::krpc::schema::Error& error() const;
  ::krpc::schema::Error* release_error();
  ::krpc::schema::Error* mutable_error();
  void set_allocated_error(::krpc::schema::Error* error);
  private:
  const ::krpc::schema::Error& _internal_error() const;
  ::krpc::schema::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::krpc::schema::Error* error);
  ::krpc::schema::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:krpc.schema.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureResult > results_;
  ::krpc::schema::Error* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class ProcedureResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.ProcedureResult) */ {
 public:
  inline ProcedureResult() : ProcedureResult(nullptr) {};
  virtual ~ProcedureResult();

  ProcedureResult(const ProcedureResult& from);
  ProcedureResult(ProcedureResult&& from) noexcept
    : ProcedureResult() {
    *this = ::std::move(from);
  }

  inline ProcedureResult& operator=(const ProcedureResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcedureResult& operator=(ProcedureResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcedureResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureResult* internal_default_instance() {
    return reinterpret_cast<const ProcedureResult*>(
               &_ProcedureResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ProcedureResult& a, ProcedureResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcedureResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcedureResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcedureResult* New() const final {
    return CreateMaybeMessage<ProcedureResult>(nullptr);
  }

  ProcedureResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcedureResult& from);
  void MergeFrom(const ProcedureResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.ProcedureResult";
  }
  protected:
  explicit ProcedureResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .krpc.schema.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::krpc::schema::Error& error() const;
  ::krpc::schema::Error* release_error();
  ::krpc::schema::Error* mutable_error();
  void set_allocated_error(::krpc::schema::Error* error);
  private:
  const ::krpc::schema::Error& _internal_error() const;
  ::krpc::schema::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::krpc::schema::Error* error);
  ::krpc::schema::Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:krpc.schema.ProcedureResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::krpc::schema::Error* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Error PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Error) */ {
 public:
  inline Error() : Error(nullptr) {};
  virtual ~Error();

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kStackTraceFieldNumber = 4,
  };
  // string service = 1;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_service();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_service(
      std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_description();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_description(
      std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string stack_trace = 4;
  void clear_stack_trace();
  const std::string& stack_trace() const;
  void set_stack_trace(const std::string& value);
  void set_stack_trace(std::string&& value);
  void set_stack_trace(const char* value);
  void set_stack_trace(const char* value, size_t size);
  std::string* mutable_stack_trace();
  std::string* release_stack_trace();
  void set_allocated_stack_trace(std::string* stack_trace);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_stack_trace();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_stack_trace(
      std::string* stack_trace);
  private:
  const std::string& _internal_stack_trace() const;
  void _internal_set_stack_trace(const std::string& value);
  std::string* _internal_mutable_stack_trace();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stack_trace_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class StreamUpdate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.StreamUpdate) */ {
 public:
  inline StreamUpdate() : StreamUpdate(nullptr) {};
  virtual ~StreamUpdate();

  StreamUpdate(const StreamUpdate& from);
  StreamUpdate(StreamUpdate&& from) noexcept
    : StreamUpdate() {
    *this = ::std::move(from);
  }

  inline StreamUpdate& operator=(const StreamUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamUpdate& operator=(StreamUpdate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamUpdate* internal_default_instance() {
    return reinterpret_cast<const StreamUpdate*>(
               &_StreamUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreamUpdate& a, StreamUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamUpdate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamUpdate* New() const final {
    return CreateMaybeMessage<StreamUpdate>(nullptr);
  }

  StreamUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamUpdate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamUpdate& from);
  void MergeFrom(const StreamUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.StreamUpdate";
  }
  protected:
  explicit StreamUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .krpc.schema.StreamResult results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::krpc::schema::StreamResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::StreamResult >*
      mutable_results();
  private:
  const ::krpc::schema::StreamResult& _internal_results(int index) const;
  ::krpc::schema::StreamResult* _internal_add_results();
  public:
  const ::krpc::schema::StreamResult& results(int index) const;
  ::krpc::schema::StreamResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::StreamResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.StreamUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::StreamResult > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class StreamResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.StreamResult) */ {
 public:
  inline StreamResult() : StreamResult(nullptr) {};
  virtual ~StreamResult();

  StreamResult(const StreamResult& from);
  StreamResult(StreamResult&& from) noexcept
    : StreamResult() {
    *this = ::std::move(from);
  }

  inline StreamResult& operator=(const StreamResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamResult& operator=(StreamResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamResult* internal_default_instance() {
    return reinterpret_cast<const StreamResult*>(
               &_StreamResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StreamResult& a, StreamResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamResult* New() const final {
    return CreateMaybeMessage<StreamResult>(nullptr);
  }

  StreamResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamResult& from);
  void MergeFrom(const StreamResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.StreamResult";
  }
  protected:
  explicit StreamResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // .krpc.schema.ProcedureResult result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::krpc::schema::ProcedureResult& result() const;
  ::krpc::schema::ProcedureResult* release_result();
  ::krpc::schema::ProcedureResult* mutable_result();
  void set_allocated_result(::krpc::schema::ProcedureResult* result);
  private:
  const ::krpc::schema::ProcedureResult& _internal_result() const;
  ::krpc::schema::ProcedureResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::krpc::schema::ProcedureResult* result);
  ::krpc::schema::ProcedureResult* unsafe_arena_release_result();

  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.StreamResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::krpc::schema::ProcedureResult* result_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Services PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Services) */ {
 public:
  inline Services() : Services(nullptr) {};
  virtual ~Services();

  Services(const Services& from);
  Services(Services&& from) noexcept
    : Services() {
    *this = ::std::move(from);
  }

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }
  inline Services& operator=(Services&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Services& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Services* internal_default_instance() {
    return reinterpret_cast<const Services*>(
               &_Services_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Services& a, Services& b) {
    a.Swap(&b);
  }
  inline void Swap(Services* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Services* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Services* New() const final {
    return CreateMaybeMessage<Services>(nullptr);
  }

  Services* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Services>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Services* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Services";
  }
  protected:
  explicit Services(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServicesFieldNumber = 1,
  };
  // repeated .krpc.schema.Service services = 1;
  int services_size() const;
  private:
  int _internal_services_size() const;
  public:
  void clear_services();
  ::krpc::schema::Service* mutable_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Service >*
      mutable_services();
  private:
  const ::krpc::schema::Service& _internal_services(int index) const;
  ::krpc::schema::Service* _internal_add_services();
  public:
  const ::krpc::schema::Service& services(int index) const;
  ::krpc::schema::Service* add_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Service >&
      services() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Services)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Service > services_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Service PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Service) */ {
 public:
  inline Service() : Service(nullptr) {};
  virtual ~Service();

  Service(const Service& from);
  Service(Service&& from) noexcept
    : Service() {
    *this = ::std::move(from);
  }

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline Service& operator=(Service&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Service& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Service* internal_default_instance() {
    return reinterpret_cast<const Service*>(
               &_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Service& a, Service& b) {
    a.Swap(&b);
  }
  inline void Swap(Service* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Service* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Service* New() const final {
    return CreateMaybeMessage<Service>(nullptr);
  }

  Service* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Service>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Service* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Service";
  }
  protected:
  explicit Service(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProceduresFieldNumber = 2,
    kClassesFieldNumber = 3,
    kEnumerationsFieldNumber = 4,
    kExceptionsFieldNumber = 5,
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 6,
  };
  // repeated .krpc.schema.Procedure procedures = 2;
  int procedures_size() const;
  private:
  int _internal_procedures_size() const;
  public:
  void clear_procedures();
  ::krpc::schema::Procedure* mutable_procedures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Procedure >*
      mutable_procedures();
  private:
  const ::krpc::schema::Procedure& _internal_procedures(int index) const;
  ::krpc::schema::Procedure* _internal_add_procedures();
  public:
  const ::krpc::schema::Procedure& procedures(int index) const;
  ::krpc::schema::Procedure* add_procedures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Procedure >&
      procedures() const;

  // repeated .krpc.schema.Class classes = 3;
  int classes_size() const;
  private:
  int _internal_classes_size() const;
  public:
  void clear_classes();
  ::krpc::schema::Class* mutable_classes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Class >*
      mutable_classes();
  private:
  const ::krpc::schema::Class& _internal_classes(int index) const;
  ::krpc::schema::Class* _internal_add_classes();
  public:
  const ::krpc::schema::Class& classes(int index) const;
  ::krpc::schema::Class* add_classes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Class >&
      classes() const;

  // repeated .krpc.schema.Enumeration enumerations = 4;
  int enumerations_size() const;
  private:
  int _internal_enumerations_size() const;
  public:
  void clear_enumerations();
  ::krpc::schema::Enumeration* mutable_enumerations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Enumeration >*
      mutable_enumerations();
  private:
  const ::krpc::schema::Enumeration& _internal_enumerations(int index) const;
  ::krpc::schema::Enumeration* _internal_add_enumerations();
  public:
  const ::krpc::schema::Enumeration& enumerations(int index) const;
  ::krpc::schema::Enumeration* add_enumerations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Enumeration >&
      enumerations() const;

  // repeated .krpc.schema.Exception exceptions = 5;
  int exceptions_size() const;
  private:
  int _internal_exceptions_size() const;
  public:
  void clear_exceptions();
  ::krpc::schema::Exception* mutable_exceptions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Exception >*
      mutable_exceptions();
  private:
  const ::krpc::schema::Exception& _internal_exceptions(int index) const;
  ::krpc::schema::Exception* _internal_add_exceptions();
  public:
  const ::krpc::schema::Exception& exceptions(int index) const;
  ::krpc::schema::Exception* add_exceptions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Exception >&
      exceptions() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 6;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Service)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Procedure > procedures_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Class > classes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Enumeration > enumerations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Exception > exceptions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Procedure PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Procedure) */ {
 public:
  inline Procedure() : Procedure(nullptr) {};
  virtual ~Procedure();

  Procedure(const Procedure& from);
  Procedure(Procedure&& from) noexcept
    : Procedure() {
    *this = ::std::move(from);
  }

  inline Procedure& operator=(const Procedure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Procedure& operator=(Procedure&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Procedure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Procedure* internal_default_instance() {
    return reinterpret_cast<const Procedure*>(
               &_Procedure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Procedure& a, Procedure& b) {
    a.Swap(&b);
  }
  inline void Swap(Procedure* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Procedure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Procedure* New() const final {
    return CreateMaybeMessage<Procedure>(nullptr);
  }

  Procedure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Procedure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Procedure& from);
  void MergeFrom(const Procedure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Procedure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Procedure";
  }
  protected:
  explicit Procedure(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Procedure_GameScene GameScene;
  static constexpr GameScene SPACE_CENTER =
    Procedure_GameScene_SPACE_CENTER;
  static constexpr GameScene FLIGHT =
    Procedure_GameScene_FLIGHT;
  static constexpr GameScene TRACKING_STATION =
    Procedure_GameScene_TRACKING_STATION;
  static constexpr GameScene EDITOR_VAB =
    Procedure_GameScene_EDITOR_VAB;
  static constexpr GameScene EDITOR_SPH =
    Procedure_GameScene_EDITOR_SPH;
  static constexpr GameScene MISSION_BUILDER =
    Procedure_GameScene_MISSION_BUILDER;
  static inline bool GameScene_IsValid(int value) {
    return Procedure_GameScene_IsValid(value);
  }
  static constexpr GameScene GameScene_MIN =
    Procedure_GameScene_GameScene_MIN;
  static constexpr GameScene GameScene_MAX =
    Procedure_GameScene_GameScene_MAX;
  static constexpr int GameScene_ARRAYSIZE =
    Procedure_GameScene_GameScene_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GameScene_descriptor() {
    return Procedure_GameScene_descriptor();
  }
  template<typename T>
  static inline const std::string& GameScene_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GameScene>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GameScene_Name.");
    return Procedure_GameScene_Name(enum_t_value);
  }
  static inline bool GameScene_Parse(const std::string& name,
      GameScene* value) {
    return Procedure_GameScene_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kGameScenesFieldNumber = 6,
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 5,
    kReturnTypeFieldNumber = 3,
    kReturnIsNullableFieldNumber = 4,
  };
  // repeated .krpc.schema.Parameter parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::krpc::schema::Parameter* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Parameter >*
      mutable_parameters();
  private:
  const ::krpc::schema::Parameter& _internal_parameters(int index) const;
  ::krpc::schema::Parameter* _internal_add_parameters();
  public:
  const ::krpc::schema::Parameter& parameters(int index) const;
  ::krpc::schema::Parameter* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Parameter >&
      parameters() const;

  // repeated .krpc.schema.Procedure.GameScene game_scenes = 6;
  int game_scenes_size() const;
  private:
  int _internal_game_scenes_size() const;
  public:
  void clear_game_scenes();
  private:
  ::krpc::schema::Procedure_GameScene _internal_game_scenes(int index) const;
  void _internal_add_game_scenes(::krpc::schema::Procedure_GameScene value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_game_scenes();
  public:
  ::krpc::schema::Procedure_GameScene game_scenes(int index) const;
  void set_game_scenes(int index, ::krpc::schema::Procedure_GameScene value);
  void add_game_scenes(::krpc::schema::Procedure_GameScene value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& game_scenes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_game_scenes();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 5;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // .krpc.schema.Type return_type = 3;
  bool has_return_type() const;
  private:
  bool _internal_has_return_type() const;
  public:
  void clear_return_type();
  const ::krpc::schema::Type& return_type() const;
  ::krpc::schema::Type* release_return_type();
  ::krpc::schema::Type* mutable_return_type();
  void set_allocated_return_type(::krpc::schema::Type* return_type);
  private:
  const ::krpc::schema::Type& _internal_return_type() const;
  ::krpc::schema::Type* _internal_mutable_return_type();
  public:
  void unsafe_arena_set_allocated_return_type(
      ::krpc::schema::Type* return_type);
  ::krpc::schema::Type* unsafe_arena_release_return_type();

  // bool return_is_nullable = 4;
  void clear_return_is_nullable();
  bool return_is_nullable() const;
  void set_return_is_nullable(bool value);
  private:
  bool _internal_return_is_nullable() const;
  void _internal_set_return_is_nullable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Procedure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Parameter > parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> game_scenes_;
  mutable std::atomic<int> _game_scenes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  ::krpc::schema::Type* return_type_;
  bool return_is_nullable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Parameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Parameter) */ {
 public:
  inline Parameter() : Parameter(nullptr) {};
  virtual ~Parameter();

  Parameter(const Parameter& from);
  Parameter(Parameter&& from) noexcept
    : Parameter() {
    *this = ::std::move(from);
  }

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Parameter& operator=(Parameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Parameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Parameter* internal_default_instance() {
    return reinterpret_cast<const Parameter*>(
               &_Parameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Parameter& a, Parameter& b) {
    a.Swap(&b);
  }
  inline void Swap(Parameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Parameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Parameter* New() const final {
    return CreateMaybeMessage<Parameter>(nullptr);
  }

  Parameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Parameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Parameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Parameter";
  }
  protected:
  explicit Parameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultValueFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes default_value = 3;
  void clear_default_value();
  const std::string& default_value() const;
  void set_default_value(const std::string& value);
  void set_default_value(std::string&& value);
  void set_default_value(const char* value);
  void set_default_value(const void* value, size_t size);
  std::string* mutable_default_value();
  std::string* release_default_value();
  void set_allocated_default_value(std::string* default_value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_default_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_default_value(
      std::string* default_value);
  private:
  const std::string& _internal_default_value() const;
  void _internal_set_default_value(const std::string& value);
  std::string* _internal_mutable_default_value();
  public:

  // .krpc.schema.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const ::krpc::schema::Type& type() const;
  ::krpc::schema::Type* release_type();
  ::krpc::schema::Type* mutable_type();
  void set_allocated_type(::krpc::schema::Type* type);
  private:
  const ::krpc::schema::Type& _internal_type() const;
  ::krpc::schema::Type* _internal_mutable_type();
  public:
  void unsafe_arena_set_allocated_type(
      ::krpc::schema::Type* type);
  ::krpc::schema::Type* unsafe_arena_release_type();

  // @@protoc_insertion_point(class_scope:krpc.schema.Parameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
  ::krpc::schema::Type* type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Class PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Class) */ {
 public:
  inline Class() : Class(nullptr) {};
  virtual ~Class();

  Class(const Class& from);
  Class(Class&& from) noexcept
    : Class() {
    *this = ::std::move(from);
  }

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }
  inline Class& operator=(Class&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Class& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Class* internal_default_instance() {
    return reinterpret_cast<const Class*>(
               &_Class_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Class& a, Class& b) {
    a.Swap(&b);
  }
  inline void Swap(Class* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Class* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Class* New() const final {
    return CreateMaybeMessage<Class>(nullptr);
  }

  Class* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Class>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Class& from);
  void MergeFrom(const Class& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Class* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Class";
  }
  protected:
  explicit Class(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 2;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Class)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Enumeration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Enumeration) */ {
 public:
  inline Enumeration() : Enumeration(nullptr) {};
  virtual ~Enumeration();

  Enumeration(const Enumeration& from);
  Enumeration(Enumeration&& from) noexcept
    : Enumeration() {
    *this = ::std::move(from);
  }

  inline Enumeration& operator=(const Enumeration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Enumeration& operator=(Enumeration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Enumeration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Enumeration* internal_default_instance() {
    return reinterpret_cast<const Enumeration*>(
               &_Enumeration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Enumeration& a, Enumeration& b) {
    a.Swap(&b);
  }
  inline void Swap(Enumeration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Enumeration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Enumeration* New() const final {
    return CreateMaybeMessage<Enumeration>(nullptr);
  }

  Enumeration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Enumeration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Enumeration& from);
  void MergeFrom(const Enumeration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Enumeration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Enumeration";
  }
  protected:
  explicit Enumeration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 3,
  };
  // repeated .krpc.schema.EnumerationValue values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::krpc::schema::EnumerationValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::EnumerationValue >*
      mutable_values();
  private:
  const ::krpc::schema::EnumerationValue& _internal_values(int index) const;
  ::krpc::schema::EnumerationValue* _internal_add_values();
  public:
  const ::krpc::schema::EnumerationValue& values(int index) const;
  ::krpc::schema::EnumerationValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::EnumerationValue >&
      values() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 3;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Enumeration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::EnumerationValue > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class EnumerationValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.EnumerationValue) */ {
 public:
  inline EnumerationValue() : EnumerationValue(nullptr) {};
  virtual ~EnumerationValue();

  EnumerationValue(const EnumerationValue& from);
  EnumerationValue(EnumerationValue&& from) noexcept
    : EnumerationValue() {
    *this = ::std::move(from);
  }

  inline EnumerationValue& operator=(const EnumerationValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumerationValue& operator=(EnumerationValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnumerationValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnumerationValue* internal_default_instance() {
    return reinterpret_cast<const EnumerationValue*>(
               &_EnumerationValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EnumerationValue& a, EnumerationValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumerationValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumerationValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnumerationValue* New() const final {
    return CreateMaybeMessage<EnumerationValue>(nullptr);
  }

  EnumerationValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnumerationValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnumerationValue& from);
  void MergeFrom(const EnumerationValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumerationValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.EnumerationValue";
  }
  protected:
  explicit EnumerationValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 3,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 3;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // int32 value = 2;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.EnumerationValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Exception PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Exception) */ {
 public:
  inline Exception() : Exception(nullptr) {};
  virtual ~Exception();

  Exception(const Exception& from);
  Exception(Exception&& from) noexcept
    : Exception() {
    *this = ::std::move(from);
  }

  inline Exception& operator=(const Exception& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exception& operator=(Exception&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Exception& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Exception* internal_default_instance() {
    return reinterpret_cast<const Exception*>(
               &_Exception_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Exception& a, Exception& b) {
    a.Swap(&b);
  }
  inline void Swap(Exception* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exception* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Exception* New() const final {
    return CreateMaybeMessage<Exception>(nullptr);
  }

  Exception* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Exception>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Exception& from);
  void MergeFrom(const Exception& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Exception* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Exception";
  }
  protected:
  explicit Exception(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocumentationFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string documentation = 2;
  void clear_documentation();
  const std::string& documentation() const;
  void set_documentation(const std::string& value);
  void set_documentation(std::string&& value);
  void set_documentation(const char* value);
  void set_documentation(const char* value, size_t size);
  std::string* mutable_documentation();
  std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_documentation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_documentation(
      std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Exception)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Type PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Type) */ {
 public:
  inline Type() : Type(nullptr) {};
  virtual ~Type();

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(nullptr);
  }

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Type_TypeCode TypeCode;
  static constexpr TypeCode NONE =
    Type_TypeCode_NONE;
  static constexpr TypeCode DOUBLE =
    Type_TypeCode_DOUBLE;
  static constexpr TypeCode FLOAT =
    Type_TypeCode_FLOAT;
  static constexpr TypeCode SINT32 =
    Type_TypeCode_SINT32;
  static constexpr TypeCode SINT64 =
    Type_TypeCode_SINT64;
  static constexpr TypeCode UINT32 =
    Type_TypeCode_UINT32;
  static constexpr TypeCode UINT64 =
    Type_TypeCode_UINT64;
  static constexpr TypeCode BOOL =
    Type_TypeCode_BOOL;
  static constexpr TypeCode STRING =
    Type_TypeCode_STRING;
  static constexpr TypeCode BYTES =
    Type_TypeCode_BYTES;
  static constexpr TypeCode CLASS =
    Type_TypeCode_CLASS;
  static constexpr TypeCode ENUMERATION =
    Type_TypeCode_ENUMERATION;
  static constexpr TypeCode EVENT =
    Type_TypeCode_EVENT;
  static constexpr TypeCode PROCEDURE_CALL =
    Type_TypeCode_PROCEDURE_CALL;
  static constexpr TypeCode STREAM =
    Type_TypeCode_STREAM;
  static constexpr TypeCode STATUS =
    Type_TypeCode_STATUS;
  static constexpr TypeCode SERVICES =
    Type_TypeCode_SERVICES;
  static constexpr TypeCode TUPLE =
    Type_TypeCode_TUPLE;
  static constexpr TypeCode LIST =
    Type_TypeCode_LIST;
  static constexpr TypeCode SET =
    Type_TypeCode_SET;
  static constexpr TypeCode DICTIONARY =
    Type_TypeCode_DICTIONARY;
  static inline bool TypeCode_IsValid(int value) {
    return Type_TypeCode_IsValid(value);
  }
  static constexpr TypeCode TypeCode_MIN =
    Type_TypeCode_TypeCode_MIN;
  static constexpr TypeCode TypeCode_MAX =
    Type_TypeCode_TypeCode_MAX;
  static constexpr int TypeCode_ARRAYSIZE =
    Type_TypeCode_TypeCode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TypeCode_descriptor() {
    return Type_TypeCode_descriptor();
  }
  template<typename T>
  static inline const std::string& TypeCode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TypeCode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TypeCode_Name.");
    return Type_TypeCode_Name(enum_t_value);
  }
  static inline bool TypeCode_Parse(const std::string& name,
      TypeCode* value) {
    return Type_TypeCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 4,
    kServiceFieldNumber = 2,
    kNameFieldNumber = 3,
    kCodeFieldNumber = 1,
  };
  // repeated .krpc.schema.Type types = 4;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::krpc::schema::Type* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Type >*
      mutable_types();
  private:
  const ::krpc::schema::Type& _internal_types(int index) const;
  ::krpc::schema::Type* _internal_add_types();
  public:
  const ::krpc::schema::Type& types(int index) const;
  ::krpc::schema::Type* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Type >&
      types() const;

  // string service = 2;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_service();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_service(
      std::string* service);
  private:
  const std::string& _internal_service() const;
  void _internal_set_service(const std::string& value);
  std::string* _internal_mutable_service();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .krpc.schema.Type.TypeCode code = 1;
  void clear_code();
  ::krpc::schema::Type_TypeCode code() const;
  void set_code(::krpc::schema::Type_TypeCode value);
  private:
  ::krpc::schema::Type_TypeCode _internal_code() const;
  void _internal_set_code(::krpc::schema::Type_TypeCode value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Type > types_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Tuple PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Tuple) */ {
 public:
  inline Tuple() : Tuple(nullptr) {};
  virtual ~Tuple();

  Tuple(const Tuple& from);
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tuple& operator=(Tuple&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Tuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }
  inline void Swap(Tuple* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Tuple* New() const final {
    return CreateMaybeMessage<Tuple>(nullptr);
  }

  Tuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Tuple";
  }
  protected:
  explicit Tuple(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated bytes items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_items();
  private:
  const std::string& _internal_items(int index) const;
  std::string* _internal_add_items();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Tuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class List PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.List) */ {
 public:
  inline List() : List(nullptr) {};
  virtual ~List();

  List(const List& from);
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  inline List& operator=(List&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }
  inline void Swap(List* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline List* New() const final {
    return CreateMaybeMessage<List>(nullptr);
  }

  List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<List>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(List* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.List";
  }
  protected:
  explicit List(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated bytes items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_items();
  private:
  const std::string& _internal_items(int index) const;
  std::string* _internal_add_items();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Set PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Set) */ {
 public:
  inline Set() : Set(nullptr) {};
  virtual ~Set();

  Set(const Set& from);
  Set(Set&& from) noexcept
    : Set() {
    *this = ::std::move(from);
  }

  inline Set& operator=(const Set& from) {
    CopyFrom(from);
    return *this;
  }
  inline Set& operator=(Set&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Set& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Set* internal_default_instance() {
    return reinterpret_cast<const Set*>(
               &_Set_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Set& a, Set& b) {
    a.Swap(&b);
  }
  inline void Swap(Set* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Set* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Set* New() const final {
    return CreateMaybeMessage<Set>(nullptr);
  }

  Set* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Set>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Set& from);
  void MergeFrom(const Set& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Set* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Set";
  }
  protected:
  explicit Set(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated bytes items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  const std::string& items(int index) const;
  std::string* mutable_items(int index);
  void set_items(int index, const std::string& value);
  void set_items(int index, std::string&& value);
  void set_items(int index, const char* value);
  void set_items(int index, const void* value, size_t size);
  std::string* add_items();
  void add_items(const std::string& value);
  void add_items(std::string&& value);
  void add_items(const char* value);
  void add_items(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& items() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_items();
  private:
  const std::string& _internal_items(int index) const;
  std::string* _internal_add_items();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Set)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Dictionary PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Dictionary) */ {
 public:
  inline Dictionary() : Dictionary(nullptr) {};
  virtual ~Dictionary();

  Dictionary(const Dictionary& from);
  Dictionary(Dictionary&& from) noexcept
    : Dictionary() {
    *this = ::std::move(from);
  }

  inline Dictionary& operator=(const Dictionary& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dictionary& operator=(Dictionary&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Dictionary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dictionary* internal_default_instance() {
    return reinterpret_cast<const Dictionary*>(
               &_Dictionary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Dictionary& a, Dictionary& b) {
    a.Swap(&b);
  }
  inline void Swap(Dictionary* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dictionary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Dictionary* New() const final {
    return CreateMaybeMessage<Dictionary>(nullptr);
  }

  Dictionary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Dictionary>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Dictionary& from);
  void MergeFrom(const Dictionary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dictionary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Dictionary";
  }
  protected:
  explicit Dictionary(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .krpc.schema.DictionaryEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::krpc::schema::DictionaryEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::DictionaryEntry >*
      mutable_entries();
  private:
  const ::krpc::schema::DictionaryEntry& _internal_entries(int index) const;
  ::krpc::schema::DictionaryEntry* _internal_add_entries();
  public:
  const ::krpc::schema::DictionaryEntry& entries(int index) const;
  ::krpc::schema::DictionaryEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::DictionaryEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:krpc.schema.Dictionary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::DictionaryEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class DictionaryEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.DictionaryEntry) */ {
 public:
  inline DictionaryEntry() : DictionaryEntry(nullptr) {};
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);
  DictionaryEntry(DictionaryEntry&& from) noexcept
    : DictionaryEntry() {
    *this = ::std::move(from);
  }

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DictionaryEntry& operator=(DictionaryEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DictionaryEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DictionaryEntry* internal_default_instance() {
    return reinterpret_cast<const DictionaryEntry*>(
               &_DictionaryEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DictionaryEntry& a, DictionaryEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(DictionaryEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DictionaryEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DictionaryEntry* New() const final {
    return CreateMaybeMessage<DictionaryEntry>(nullptr);
  }

  DictionaryEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DictionaryEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DictionaryEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.DictionaryEntry";
  }
  protected:
  explicit DictionaryEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_value();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_value(
      std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.DictionaryEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Stream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {};
  virtual ~Stream();

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(nullptr);
  }

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Event PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Event) */ {
 public:
  inline Event() : Event(nullptr) {};
  virtual ~Event();

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
  };
  // .krpc.schema.Stream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::krpc::schema::Stream& stream() const;
  ::krpc::schema::Stream* release_stream();
  ::krpc::schema::Stream* mutable_stream();
  void set_allocated_stream(::krpc::schema::Stream* stream);
  private:
  const ::krpc::schema::Stream& _internal_stream() const;
  ::krpc::schema::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::krpc::schema::Stream* stream);
  ::krpc::schema::Stream* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:krpc.schema.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::krpc::schema::Stream* stream_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.Status) */ {
 public:
  inline Status() : Status(nullptr) {};
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kBytesReadFieldNumber = 2,
    kBytesWrittenFieldNumber = 3,
    kBytesReadRateFieldNumber = 4,
    kBytesWrittenRateFieldNumber = 5,
    kRpcsExecutedFieldNumber = 6,
    kRpcRateFieldNumber = 7,
    kMaxTimePerUpdateFieldNumber = 9,
    kOneRpcPerUpdateFieldNumber = 8,
    kAdaptiveRateControlFieldNumber = 10,
    kBlockingRecvFieldNumber = 11,
    kRecvTimeoutFieldNumber = 12,
    kTimePerRpcUpdateFieldNumber = 13,
    kPollTimePerRpcUpdateFieldNumber = 14,
    kExecTimePerRpcUpdateFieldNumber = 15,
    kStreamRpcsFieldNumber = 16,
    kStreamRpcsExecutedFieldNumber = 17,
    kStreamRpcRateFieldNumber = 18,
    kTimePerStreamUpdateFieldNumber = 19,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version(
      std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 bytes_read = 2;
  void clear_bytes_read();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_read() const;
  void set_bytes_read(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_read() const;
  void _internal_set_bytes_read(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 bytes_written = 3;
  void clear_bytes_written();
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_written() const;
  void set_bytes_written(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bytes_written() const;
  void _internal_set_bytes_written(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float bytes_read_rate = 4;
  void clear_bytes_read_rate();
  float bytes_read_rate() const;
  void set_bytes_read_rate(float value);
  private:
  float _internal_bytes_read_rate() const;
  void _internal_set_bytes_read_rate(float value);
  public:

  // float bytes_written_rate = 5;
  void clear_bytes_written_rate();
  float bytes_written_rate() const;
  void set_bytes_written_rate(float value);
  private:
  float _internal_bytes_written_rate() const;
  void _internal_set_bytes_written_rate(float value);
  public:

  // uint64 rpcs_executed = 6;
  void clear_rpcs_executed();
  ::PROTOBUF_NAMESPACE_ID::uint64 rpcs_executed() const;
  void set_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rpcs_executed() const;
  void _internal_set_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float rpc_rate = 7;
  void clear_rpc_rate();
  float rpc_rate() const;
  void set_rpc_rate(float value);
  private:
  float _internal_rpc_rate() const;
  void _internal_set_rpc_rate(float value);
  public:

  // uint32 max_time_per_update = 9;
  void clear_max_time_per_update();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_time_per_update() const;
  void set_max_time_per_update(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_time_per_update() const;
  void _internal_set_max_time_per_update(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool one_rpc_per_update = 8;
  void clear_one_rpc_per_update();
  bool one_rpc_per_update() const;
  void set_one_rpc_per_update(bool value);
  private:
  bool _internal_one_rpc_per_update() const;
  void _internal_set_one_rpc_per_update(bool value);
  public:

  // bool adaptive_rate_control = 10;
  void clear_adaptive_rate_control();
  bool adaptive_rate_control() const;
  void set_adaptive_rate_control(bool value);
  private:
  bool _internal_adaptive_rate_control() const;
  void _internal_set_adaptive_rate_control(bool value);
  public:

  // bool blocking_recv = 11;
  void clear_blocking_recv();
  bool blocking_recv() const;
  void set_blocking_recv(bool value);
  private:
  bool _internal_blocking_recv() const;
  void _internal_set_blocking_recv(bool value);
  public:

  // uint32 recv_timeout = 12;
  void clear_recv_timeout();
  ::PROTOBUF_NAMESPACE_ID::uint32 recv_timeout() const;
  void set_recv_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_recv_timeout() const;
  void _internal_set_recv_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float time_per_rpc_update = 13;
  void clear_time_per_rpc_update();
  float time_per_rpc_update() const;
  void set_time_per_rpc_update(float value);
  private:
  float _internal_time_per_rpc_update() const;
  void _internal_set_time_per_rpc_update(float value);
  public:

  // float poll_time_per_rpc_update = 14;
  void clear_poll_time_per_rpc_update();
  float poll_time_per_rpc_update() const;
  void set_poll_time_per_rpc_update(float value);
  private:
  float _internal_poll_time_per_rpc_update() const;
  void _internal_set_poll_time_per_rpc_update(float value);
  public:

  // float exec_time_per_rpc_update = 15;
  void clear_exec_time_per_rpc_update();
  float exec_time_per_rpc_update() const;
  void set_exec_time_per_rpc_update(float value);
  private:
  float _internal_exec_time_per_rpc_update() const;
  void _internal_set_exec_time_per_rpc_update(float value);
  public:

  // uint32 stream_rpcs = 16;
  void clear_stream_rpcs();
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_rpcs() const;
  void set_stream_rpcs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_stream_rpcs() const;
  void _internal_set_stream_rpcs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 stream_rpcs_executed = 17;
  void clear_stream_rpcs_executed();
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_rpcs_executed() const;
  void set_stream_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_stream_rpcs_executed() const;
  void _internal_set_stream_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // float stream_rpc_rate = 18;
  void clear_stream_rpc_rate();
  float stream_rpc_rate() const;
  void set_stream_rpc_rate(float value);
  private:
  float _internal_stream_rpc_rate() const;
  void _internal_set_stream_rpc_rate(float value);
  public:

  // float time_per_stream_update = 19;
  void clear_time_per_stream_update();
  float time_per_stream_update() const;
  void set_time_per_stream_update(float value);
  private:
  float _internal_time_per_stream_update() const;
  void _internal_set_time_per_stream_update(float value);
  public:

  // @@protoc_insertion_point(class_scope:krpc.schema.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_read_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bytes_written_;
  float bytes_read_rate_;
  float bytes_written_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rpcs_executed_;
  float rpc_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_time_per_update_;
  bool one_rpc_per_update_;
  bool adaptive_rate_control_;
  bool blocking_recv_;
  ::PROTOBUF_NAMESPACE_ID::uint32 recv_timeout_;
  float time_per_rpc_update_;
  float poll_time_per_rpc_update_;
  float exec_time_per_rpc_update_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stream_rpcs_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_rpcs_executed_;
  float stream_rpc_rate_;
  float time_per_stream_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class MultiplexedRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.MultiplexedRequest) */ {
 public:
  inline MultiplexedRequest() : MultiplexedRequest(nullptr) {};
  virtual ~MultiplexedRequest();

  MultiplexedRequest(const MultiplexedRequest& from);
  MultiplexedRequest(MultiplexedRequest&& from) noexcept
    : MultiplexedRequest() {
    *this = ::std::move(from);
  }

  inline MultiplexedRequest& operator=(const MultiplexedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexedRequest& operator=(MultiplexedRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiplexedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplexedRequest* internal_default_instance() {
    return reinterpret_cast<const MultiplexedRequest*>(
               &_MultiplexedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(MultiplexedRequest& a, MultiplexedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexedRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiplexedRequest* New() const final {
    return CreateMaybeMessage<MultiplexedRequest>(nullptr);
  }

  MultiplexedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiplexedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiplexedRequest& from);
  void MergeFrom(const MultiplexedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplexedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.MultiplexedRequest";
  }
  protected:
  explicit MultiplexedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectionRequestFieldNumber = 1,
    kRequestFieldNumber = 2,
  };
  // .krpc.schema.ConnectionRequest connection_request = 1;
  bool has_connection_request() const;
  private:
  bool _internal_has_connection_request() const;
  public:
  void clear_connection_request();
  const ::krpc::schema::ConnectionRequest& connection_request() const;
  ::krpc::schema::ConnectionRequest* release_connection_request();
  ::krpc::schema::ConnectionRequest* mutable_connection_request();
  void set_allocated_connection_request(::krpc::schema::ConnectionRequest* connection_request);
  private:
  const ::krpc::schema::ConnectionRequest& _internal_connection_request() const;
  ::krpc::schema::ConnectionRequest* _internal_mutable_connection_request();
  public:
  void unsafe_arena_set_allocated_connection_request(
      ::krpc::schema::ConnectionRequest* connection_request);
  ::krpc::schema::ConnectionRequest* unsafe_arena_release_connection_request();

  // .krpc.schema.Request request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::krpc::schema::Request& request() const;
  ::krpc::schema::Request* release_request();
  ::krpc::schema::Request* mutable_request();
  void set_allocated_request(::krpc::schema::Request* request);
  private:
  const ::krpc::schema::Request& _internal_request() const;
  ::krpc::schema::Request* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::krpc::schema::Request* request);
  ::krpc::schema::Request* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:krpc.schema.MultiplexedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::krpc::schema::ConnectionRequest* connection_request_;
  ::krpc::schema::Request* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// -------------------------------------------------------------------

class MultiplexedResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:krpc.schema.MultiplexedResponse) */ {
 public:
  inline MultiplexedResponse() : MultiplexedResponse(nullptr) {};
  virtual ~MultiplexedResponse();

  MultiplexedResponse(const MultiplexedResponse& from);
  MultiplexedResponse(MultiplexedResponse&& from) noexcept
    : MultiplexedResponse() {
    *this = ::std::move(from);
  }

  inline MultiplexedResponse& operator=(const MultiplexedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiplexedResponse& operator=(MultiplexedResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiplexedResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiplexedResponse* internal_default_instance() {
    return reinterpret_cast<const MultiplexedResponse*>(
               &_MultiplexedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MultiplexedResponse& a, MultiplexedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiplexedResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiplexedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiplexedResponse* New() const final {
    return CreateMaybeMessage<MultiplexedResponse>(nullptr);
  }

  MultiplexedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiplexedResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiplexedResponse& from);
  void MergeFrom(const MultiplexedResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiplexedResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "krpc.schema.MultiplexedResponse";
  }
  protected:
  explicit MultiplexedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_krpc_2eproto);
    return ::descriptor_table_krpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kStreamUpdateFieldNumber = 2,
  };
  // .krpc.schema.Response response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const ::krpc::schema::Response& response() const;
  ::krpc::schema::Response* release_response();
  ::krpc::schema::Response* mutable_response();
  void set_allocated_response(::krpc::schema::Response* response);
  private:
  const ::krpc::schema::Response& _internal_response() const;
  ::krpc::schema::Response* _internal_mutable_response();
  public:
  void unsafe_arena_set_allocated_response(
      ::krpc::schema::Response* response);
  ::krpc::schema::Response* unsafe_arena_release_response();

  // .krpc.schema.StreamUpdate stream_update = 2;
  bool has_stream_update() const;
  private:
  bool _internal_has_stream_update() const;
  public:
  void clear_stream_update();
  const ::krpc::schema::StreamUpdate& stream_update() const;
  ::krpc::schema::StreamUpdate* release_stream_update();
  ::krpc::schema::StreamUpdate* mutable_stream_update();
  void set_allocated_stream_update(::krpc::schema::StreamUpdate* stream_update);
  private:
  const ::krpc::schema::StreamUpdate& _internal_stream_update() const;
  ::krpc::schema::StreamUpdate* _internal_mutable_stream_update();
  public:
  void unsafe_arena_set_allocated_stream_update(
      ::krpc::schema::StreamUpdate* stream_update);
  ::krpc::schema::StreamUpdate* unsafe_arena_release_stream_update();

  // @@protoc_insertion_point(class_scope:krpc.schema.MultiplexedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::krpc::schema::Response* response_;
  ::krpc::schema::StreamUpdate* stream_update_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_krpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConnectionRequest

// .krpc.schema.ConnectionRequest.Type type = 1;
inline void ConnectionRequest::clear_type() {
  type_ = 0;
}
inline ::krpc::schema::ConnectionRequest_Type ConnectionRequest::_internal_type() const {
  return static_cast< ::krpc::schema::ConnectionRequest_Type >(type_);
}
inline ::krpc::schema::ConnectionRequest_Type ConnectionRequest::type() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.type)
  return _internal_type();
}
inline void ConnectionRequest::_internal_set_type(::krpc::schema::ConnectionRequest_Type value) {
  
  type_ = value;
}
inline void ConnectionRequest::set_type(::krpc::schema::ConnectionRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.type)
}

// string client_name = 2;
inline void ConnectionRequest::clear_client_name() {
  client_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionRequest::client_name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.client_name)
  return _internal_client_name();
}
inline void ConnectionRequest::set_client_name(const std::string& value) {
  _internal_set_client_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.client_name)
}
inline std::string* ConnectionRequest::mutable_client_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionRequest.client_name)
  return _internal_mutable_client_name();
}
inline const std::string& ConnectionRequest::_internal_client_name() const {
  return client_name_.Get();
}
inline void ConnectionRequest::_internal_set_client_name(const std::string& value) {
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionRequest::set_client_name(std::string&& value) {
  
  client_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionRequest.client_name)
}
inline void ConnectionRequest::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionRequest.client_name)
}
inline void ConnectionRequest::set_client_name(const char* value,
    size_t size) {
  
  client_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionRequest.client_name)
}
inline std::string* ConnectionRequest::_internal_mutable_client_name() {
  
  return client_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionRequest::release_client_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionRequest.client_name)
  return client_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionRequest::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionRequest.client_name)
}
inline std::string* ConnectionRequest::unsafe_arena_release_client_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ConnectionRequest.client_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return client_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionRequest::unsafe_arena_set_allocated_client_name(
    std::string* client_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (client_name != nullptr) {
    
  } else {
    
  }
  client_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      client_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ConnectionRequest.client_name)
}

// bytes client_identifier = 3;
inline void ConnectionRequest::clear_client_identifier() {
  client_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionRequest::client_identifier() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionRequest.client_identifier)
  return _internal_client_identifier();
}
inline void ConnectionRequest::set_client_identifier(const std::string& value) {
  _internal_set_client_identifier(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionRequest.client_identifier)
}
inline std::string* ConnectionRequest::mutable_client_identifier() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionRequest.client_identifier)
  return _internal_mutable_client_identifier();
}
inline const std::string& ConnectionRequest::_internal_client_identifier() const {
  return client_identifier_.Get();
}
inline void ConnectionRequest::_internal_set_client_identifier(const std::string& value) {
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionRequest::set_client_identifier(std::string&& value) {
  
  client_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionRequest.client_identifier)
}
inline void ConnectionRequest::set_client_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionRequest.client_identifier)
}
inline void ConnectionRequest::set_client_identifier(const void* value,
    size_t size) {
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionRequest.client_identifier)
}
inline std::string* ConnectionRequest::_internal_mutable_client_identifier() {
  
  return client_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionRequest::release_client_identifier() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionRequest.client_identifier)
  return client_identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionRequest::set_allocated_client_identifier(std::string* client_identifier) {
  if (client_identifier != nullptr) {
    
  } else {
    
  }
  client_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionRequest.client_identifier)
}
inline std::string* ConnectionRequest::unsafe_arena_release_client_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ConnectionRequest.client_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return client_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionRequest::unsafe_arena_set_allocated_client_identifier(
    std::string* client_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (client_identifier != nullptr) {
    
  } else {
    
  }
  client_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      client_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ConnectionRequest.client_identifier)
}

// -------------------------------------------------------------------

// ConnectionResponse

// .krpc.schema.ConnectionResponse.Status status = 1;
inline void ConnectionResponse::clear_status() {
  status_ = 0;
}
inline ::krpc::schema::ConnectionResponse_Status ConnectionResponse::_internal_status() const {
  return static_cast< ::krpc::schema::ConnectionResponse_Status >(status_);
}
inline ::krpc::schema::ConnectionResponse_Status ConnectionResponse::status() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.status)
  return _internal_status();
}
inline void ConnectionResponse::_internal_set_status(::krpc::schema::ConnectionResponse_Status value) {
  
  status_ = value;
}
inline void ConnectionResponse::set_status(::krpc::schema::ConnectionResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.status)
}

// string message = 2;
inline void ConnectionResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionResponse::message() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.message)
  return _internal_message();
}
inline void ConnectionResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.message)
}
inline std::string* ConnectionResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionResponse.message)
  return _internal_mutable_message();
}
inline const std::string& ConnectionResponse::_internal_message() const {
  return message_.Get();
}
inline void ConnectionResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionResponse.message)
}
inline void ConnectionResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionResponse.message)
}
inline void ConnectionResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionResponse.message)
}
inline std::string* ConnectionResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionResponse::release_message() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionResponse.message)
}
inline std::string* ConnectionResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ConnectionResponse.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionResponse::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ConnectionResponse.message)
}

// bytes client_identifier = 3;
inline void ConnectionResponse::clear_client_identifier() {
  client_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ConnectionResponse::client_identifier() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ConnectionResponse.client_identifier)
  return _internal_client_identifier();
}
inline void ConnectionResponse::set_client_identifier(const std::string& value) {
  _internal_set_client_identifier(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ConnectionResponse.client_identifier)
}
inline std::string* ConnectionResponse::mutable_client_identifier() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ConnectionResponse.client_identifier)
  return _internal_mutable_client_identifier();
}
inline const std::string& ConnectionResponse::_internal_client_identifier() const {
  return client_identifier_.Get();
}
inline void ConnectionResponse::_internal_set_client_identifier(const std::string& value) {
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectionResponse::set_client_identifier(std::string&& value) {
  
  client_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ConnectionResponse.client_identifier)
}
inline void ConnectionResponse::set_client_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ConnectionResponse.client_identifier)
}
inline void ConnectionResponse::set_client_identifier(const void* value,
    size_t size) {
  
  client_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ConnectionResponse.client_identifier)
}
inline std::string* ConnectionResponse::_internal_mutable_client_identifier() {
  
  return client_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectionResponse::release_client_identifier() {
  // @@protoc_insertion_point(field_release:krpc.schema.ConnectionResponse.client_identifier)
  return client_identifier_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectionResponse::set_allocated_client_identifier(std::string* client_identifier) {
  if (client_identifier != nullptr) {
    
  } else {
    
  }
  client_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ConnectionResponse.client_identifier)
}
inline std::string* ConnectionResponse::unsafe_arena_release_client_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ConnectionResponse.client_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return client_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectionResponse::unsafe_arena_set_allocated_client_identifier(
    std::string* client_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (client_identifier != nullptr) {
    
  } else {
    
  }
  client_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      client_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ConnectionResponse.client_identifier)
}

// -------------------------------------------------------------------

// Request

// repeated .krpc.schema.ProcedureCall calls = 1;
inline int Request::_internal_calls_size() const {
  return calls_.size();
}
inline int Request::calls_size() const {
  return _internal_calls_size();
}
inline void Request::clear_calls() {
  calls_.Clear();
}
inline ::krpc::schema::ProcedureCall* Request::mutable_calls(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Request.calls)
  return calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureCall >*
Request::mutable_calls() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Request.calls)
  return &calls_;
}
inline const ::krpc::schema::ProcedureCall& Request::_internal_calls(int index) const {
  return calls_.Get(index);
}
inline const ::krpc::schema::ProcedureCall& Request::calls(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Request.calls)
  return _internal_calls(index);
}
inline ::krpc::schema::ProcedureCall* Request::_internal_add_calls() {
  return calls_.Add();
}
inline ::krpc::schema::ProcedureCall* Request::add_calls() {
  // @@protoc_insertion_point(field_add:krpc.schema.Request.calls)
  return _internal_add_calls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureCall >&
Request::calls() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Request.calls)
  return calls_;
}

// -------------------------------------------------------------------

// ProcedureCall

// string service = 1;
inline void ProcedureCall::clear_service() {
  service_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProcedureCall::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.service)
  return _internal_service();
}
inline void ProcedureCall::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.service)
}
inline std::string* ProcedureCall::mutable_service() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.service)
  return _internal_mutable_service();
}
inline const std::string& ProcedureCall::_internal_service() const {
  return service_.Get();
}
inline void ProcedureCall::_internal_set_service(const std::string& value) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProcedureCall::set_service(std::string&& value) {
  
  service_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureCall.service)
}
inline void ProcedureCall::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureCall.service)
}
inline void ProcedureCall::set_service(const char* value,
    size_t size) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureCall.service)
}
inline std::string* ProcedureCall::_internal_mutable_service() {
  
  return service_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProcedureCall::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureCall.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProcedureCall::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureCall.service)
}
inline std::string* ProcedureCall::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ProcedureCall.service)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return service_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProcedureCall::unsafe_arena_set_allocated_service(
    std::string* service) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (service != nullptr) {
    
  } else {
    
  }
  service_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      service, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ProcedureCall.service)
}

// string procedure = 2;
inline void ProcedureCall::clear_procedure() {
  procedure_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProcedureCall::procedure() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.procedure)
  return _internal_procedure();
}
inline void ProcedureCall::set_procedure(const std::string& value) {
  _internal_set_procedure(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.procedure)
}
inline std::string* ProcedureCall::mutable_procedure() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.procedure)
  return _internal_mutable_procedure();
}
inline const std::string& ProcedureCall::_internal_procedure() const {
  return procedure_.Get();
}
inline void ProcedureCall::_internal_set_procedure(const std::string& value) {
  
  procedure_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProcedureCall::set_procedure(std::string&& value) {
  
  procedure_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureCall.procedure)
}
inline void ProcedureCall::set_procedure(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  procedure_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureCall.procedure)
}
inline void ProcedureCall::set_procedure(const char* value,
    size_t size) {
  
  procedure_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureCall.procedure)
}
inline std::string* ProcedureCall::_internal_mutable_procedure() {
  
  return procedure_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProcedureCall::release_procedure() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureCall.procedure)
  return procedure_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProcedureCall::set_allocated_procedure(std::string* procedure) {
  if (procedure != nullptr) {
    
  } else {
    
  }
  procedure_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), procedure,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureCall.procedure)
}
inline std::string* ProcedureCall::unsafe_arena_release_procedure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ProcedureCall.procedure)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return procedure_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProcedureCall::unsafe_arena_set_allocated_procedure(
    std::string* procedure) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (procedure != nullptr) {
    
  } else {
    
  }
  procedure_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      procedure, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ProcedureCall.procedure)
}

// uint32 service_id = 4;
inline void ProcedureCall::clear_service_id() {
  service_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcedureCall::_internal_service_id() const {
  return service_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcedureCall::service_id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.service_id)
  return _internal_service_id();
}
inline void ProcedureCall::_internal_set_service_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  service_id_ = value;
}
inline void ProcedureCall::set_service_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_service_id(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.service_id)
}

// uint32 procedure_id = 5;
inline void ProcedureCall::clear_procedure_id() {
  procedure_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcedureCall::_internal_procedure_id() const {
  return procedure_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProcedureCall::procedure_id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.procedure_id)
  return _internal_procedure_id();
}
inline void ProcedureCall::_internal_set_procedure_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  procedure_id_ = value;
}
inline void ProcedureCall::set_procedure_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_procedure_id(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureCall.procedure_id)
}

// repeated .krpc.schema.Argument arguments = 3;
inline int ProcedureCall::_internal_arguments_size() const {
  return arguments_.size();
}
inline int ProcedureCall::arguments_size() const {
  return _internal_arguments_size();
}
inline void ProcedureCall::clear_arguments() {
  arguments_.Clear();
}
inline ::krpc::schema::Argument* ProcedureCall::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureCall.arguments)
  return arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Argument >*
ProcedureCall::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.ProcedureCall.arguments)
  return &arguments_;
}
inline const ::krpc::schema::Argument& ProcedureCall::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const ::krpc::schema::Argument& ProcedureCall::arguments(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureCall.arguments)
  return _internal_arguments(index);
}
inline ::krpc::schema::Argument* ProcedureCall::_internal_add_arguments() {
  return arguments_.Add();
}
inline ::krpc::schema::Argument* ProcedureCall::add_arguments() {
  // @@protoc_insertion_point(field_add:krpc.schema.ProcedureCall.arguments)
  return _internal_add_arguments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Argument >&
ProcedureCall::arguments() const {
  // @@protoc_insertion_point(field_list:krpc.schema.ProcedureCall.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// Argument

// uint32 position = 1;
inline void Argument::clear_position() {
  position_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Argument::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Argument::position() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Argument.position)
  return _internal_position();
}
inline void Argument::_internal_set_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  position_ = value;
}
inline void Argument::set_position(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Argument.position)
}

// bytes value = 2;
inline void Argument::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Argument::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Argument.value)
  return _internal_value();
}
inline void Argument::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Argument.value)
}
inline std::string* Argument::mutable_value() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Argument.value)
  return _internal_mutable_value();
}
inline const std::string& Argument::_internal_value() const {
  return value_.Get();
}
inline void Argument::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Argument::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Argument.value)
}
inline void Argument::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Argument.value)
}
inline void Argument::set_value(const void* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Argument.value)
}
inline std::string* Argument::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Argument::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.Argument.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Argument::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Argument.value)
}
inline std::string* Argument::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Argument.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Argument::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Argument.value)
}

// -------------------------------------------------------------------

// Response

// .krpc.schema.Error error = 1;
inline bool Response::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool Response::has_error() const {
  return _internal_has_error();
}
inline void Response::clear_error() {
  if (GetArena() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::krpc::schema::Error& Response::_internal_error() const {
  const ::krpc::schema::Error* p = error_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Error*>(
      &::krpc::schema::_Error_default_instance_);
}
inline const ::krpc::schema::Error& Response::error() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Response.error)
  return _internal_error();
}
inline void Response::unsafe_arena_set_allocated_error(
    ::krpc::schema::Error* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Response.error)
}
inline ::krpc::schema::Error* Response::release_error() {
  auto temp = unsafe_arena_release_error();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Error* Response::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:krpc.schema.Response.error)
  
  ::krpc::schema::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::krpc::schema::Error* Response::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Error>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::krpc::schema::Error* Response::mutable_error() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Response.error)
  return _internal_mutable_error();
}
inline void Response::set_allocated_error(::krpc::schema::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Response.error)
}

// repeated .krpc.schema.ProcedureResult results = 2;
inline int Response::_internal_results_size() const {
  return results_.size();
}
inline int Response::results_size() const {
  return _internal_results_size();
}
inline void Response::clear_results() {
  results_.Clear();
}
inline ::krpc::schema::ProcedureResult* Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureResult >*
Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Response.results)
  return &results_;
}
inline const ::krpc::schema::ProcedureResult& Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::krpc::schema::ProcedureResult& Response::results(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Response.results)
  return _internal_results(index);
}
inline ::krpc::schema::ProcedureResult* Response::_internal_add_results() {
  return results_.Add();
}
inline ::krpc::schema::ProcedureResult* Response::add_results() {
  // @@protoc_insertion_point(field_add:krpc.schema.Response.results)
  return _internal_add_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::ProcedureResult >&
Response::results() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Response.results)
  return results_;
}

// -------------------------------------------------------------------

// ProcedureResult

// .krpc.schema.Error error = 1;
inline bool ProcedureResult::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool ProcedureResult::has_error() const {
  return _internal_has_error();
}
inline void ProcedureResult::clear_error() {
  if (GetArena() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::krpc::schema::Error& ProcedureResult::_internal_error() const {
  const ::krpc::schema::Error* p = error_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Error*>(
      &::krpc::schema::_Error_default_instance_);
}
inline const ::krpc::schema::Error& ProcedureResult::error() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureResult.error)
  return _internal_error();
}
inline void ProcedureResult::unsafe_arena_set_allocated_error(
    ::krpc::schema::Error* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ProcedureResult.error)
}
inline ::krpc::schema::Error* ProcedureResult::release_error() {
  auto temp = unsafe_arena_release_error();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Error* ProcedureResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureResult.error)
  
  ::krpc::schema::Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::krpc::schema::Error* ProcedureResult::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Error>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::krpc::schema::Error* ProcedureResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureResult.error)
  return _internal_mutable_error();
}
inline void ProcedureResult::set_allocated_error(::krpc::schema::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureResult.error)
}

// bytes value = 2;
inline void ProcedureResult::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProcedureResult::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.ProcedureResult.value)
  return _internal_value();
}
inline void ProcedureResult::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:krpc.schema.ProcedureResult.value)
}
inline std::string* ProcedureResult::mutable_value() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.ProcedureResult.value)
  return _internal_mutable_value();
}
inline const std::string& ProcedureResult::_internal_value() const {
  return value_.Get();
}
inline void ProcedureResult::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProcedureResult::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.ProcedureResult.value)
}
inline void ProcedureResult::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.ProcedureResult.value)
}
inline void ProcedureResult::set_value(const void* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.ProcedureResult.value)
}
inline std::string* ProcedureResult::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProcedureResult::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.ProcedureResult.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProcedureResult::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.ProcedureResult.value)
}
inline std::string* ProcedureResult::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.ProcedureResult.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProcedureResult::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.ProcedureResult.value)
}

// -------------------------------------------------------------------

// Error

// string service = 1;
inline void Error::clear_service() {
  service_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Error::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.service)
  return _internal_service();
}
inline void Error::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.service)
}
inline std::string* Error::mutable_service() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.service)
  return _internal_mutable_service();
}
inline const std::string& Error::_internal_service() const {
  return service_.Get();
}
inline void Error::_internal_set_service(const std::string& value) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Error::set_service(std::string&& value) {
  
  service_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.service)
}
inline void Error::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.service)
}
inline void Error::set_service(const char* value,
    size_t size) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.service)
}
inline std::string* Error::_internal_mutable_service() {
  
  return service_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Error::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.service)
}
inline std::string* Error::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Error.service)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return service_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Error::unsafe_arena_set_allocated_service(
    std::string* service) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (service != nullptr) {
    
  } else {
    
  }
  service_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      service, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Error.service)
}

// string name = 2;
inline void Error::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Error::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.name)
  return _internal_name();
}
inline void Error::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.name)
}
inline std::string* Error::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.name)
  return _internal_mutable_name();
}
inline const std::string& Error::_internal_name() const {
  return name_.Get();
}
inline void Error::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Error::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.name)
}
inline void Error::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.name)
}
inline void Error::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.name)
}
inline std::string* Error::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Error::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.name)
}
inline std::string* Error::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Error.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Error::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Error.name)
}

// string description = 3;
inline void Error::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Error::description() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.description)
  return _internal_description();
}
inline void Error::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.description)
}
inline std::string* Error::mutable_description() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.description)
  return _internal_mutable_description();
}
inline const std::string& Error::_internal_description() const {
  return description_.Get();
}
inline void Error::_internal_set_description(const std::string& value) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Error::set_description(std::string&& value) {
  
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.description)
}
inline void Error::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.description)
}
inline void Error::set_description(const char* value,
    size_t size) {
  
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.description)
}
inline std::string* Error::_internal_mutable_description() {
  
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Error::release_description() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.description)
}
inline std::string* Error::unsafe_arena_release_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Error.description)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return description_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Error::unsafe_arena_set_allocated_description(
    std::string* description) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (description != nullptr) {
    
  } else {
    
  }
  description_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      description, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Error.description)
}

// string stack_trace = 4;
inline void Error::clear_stack_trace() {
  stack_trace_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Error::stack_trace() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Error.stack_trace)
  return _internal_stack_trace();
}
inline void Error::set_stack_trace(const std::string& value) {
  _internal_set_stack_trace(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Error.stack_trace)
}
inline std::string* Error::mutable_stack_trace() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Error.stack_trace)
  return _internal_mutable_stack_trace();
}
inline const std::string& Error::_internal_stack_trace() const {
  return stack_trace_.Get();
}
inline void Error::_internal_set_stack_trace(const std::string& value) {
  
  stack_trace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Error::set_stack_trace(std::string&& value) {
  
  stack_trace_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Error.stack_trace)
}
inline void Error::set_stack_trace(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  stack_trace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Error.stack_trace)
}
inline void Error::set_stack_trace(const char* value,
    size_t size) {
  
  stack_trace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Error.stack_trace)
}
inline std::string* Error::_internal_mutable_stack_trace() {
  
  return stack_trace_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Error::release_stack_trace() {
  // @@protoc_insertion_point(field_release:krpc.schema.Error.stack_trace)
  return stack_trace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Error::set_allocated_stack_trace(std::string* stack_trace) {
  if (stack_trace != nullptr) {
    
  } else {
    
  }
  stack_trace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stack_trace,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Error.stack_trace)
}
inline std::string* Error::unsafe_arena_release_stack_trace() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Error.stack_trace)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return stack_trace_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Error::unsafe_arena_set_allocated_stack_trace(
    std::string* stack_trace) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (stack_trace != nullptr) {
    
  } else {
    
  }
  stack_trace_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      stack_trace, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Error.stack_trace)
}

// -------------------------------------------------------------------

// StreamUpdate

// repeated .krpc.schema.StreamResult results = 1;
inline int StreamUpdate::_internal_results_size() const {
  return results_.size();
}
inline int StreamUpdate::results_size() const {
  return _internal_results_size();
}
inline void StreamUpdate::clear_results() {
  results_.Clear();
}
inline ::krpc::schema::StreamResult* StreamUpdate::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.StreamUpdate.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::StreamResult >*
StreamUpdate::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.StreamUpdate.results)
  return &results_;
}
inline const ::krpc::schema::StreamResult& StreamUpdate::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::krpc::schema::StreamResult& StreamUpdate::results(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.StreamUpdate.results)
  return _internal_results(index);
}
inline ::krpc::schema::StreamResult* StreamUpdate::_internal_add_results() {
  return results_.Add();
}
inline ::krpc::schema::StreamResult* StreamUpdate::add_results() {
  // @@protoc_insertion_point(field_add:krpc.schema.StreamUpdate.results)
  return _internal_add_results();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::StreamResult >&
StreamUpdate::results() const {
  // @@protoc_insertion_point(field_list:krpc.schema.StreamUpdate.results)
  return results_;
}

// -------------------------------------------------------------------

// StreamResult

// uint64 id = 1;
inline void StreamResult::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StreamResult::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StreamResult::id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.StreamResult.id)
  return _internal_id();
}
inline void StreamResult::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void StreamResult::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:krpc.schema.StreamResult.id)
}

// .krpc.schema.ProcedureResult result = 2;
inline bool StreamResult::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool StreamResult::has_result() const {
  return _internal_has_result();
}
inline void StreamResult::clear_result() {
  if (GetArena() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::krpc::schema::ProcedureResult& StreamResult::_internal_result() const {
  const ::krpc::schema::ProcedureResult* p = result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::ProcedureResult*>(
      &::krpc::schema::_ProcedureResult_default_instance_);
}
inline const ::krpc::schema::ProcedureResult& StreamResult::result() const {
  // @@protoc_insertion_point(field_get:krpc.schema.StreamResult.result)
  return _internal_result();
}
inline void StreamResult::unsafe_arena_set_allocated_result(
    ::krpc::schema::ProcedureResult* result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.StreamResult.result)
}
inline ::krpc::schema::ProcedureResult* StreamResult::release_result() {
  auto temp = unsafe_arena_release_result();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::ProcedureResult* StreamResult::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:krpc.schema.StreamResult.result)
  
  ::krpc::schema::ProcedureResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::krpc::schema::ProcedureResult* StreamResult::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::ProcedureResult>(GetArena());
    result_ = p;
  }
  return result_;
}
inline ::krpc::schema::ProcedureResult* StreamResult::mutable_result() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.StreamResult.result)
  return _internal_mutable_result();
}
inline void StreamResult::set_allocated_result(::krpc::schema::ProcedureResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.StreamResult.result)
}

// -------------------------------------------------------------------

// Services

// repeated .krpc.schema.Service services = 1;
inline int Services::_internal_services_size() const {
  return services_.size();
}
inline int Services::services_size() const {
  return _internal_services_size();
}
inline void Services::clear_services() {
  services_.Clear();
}
inline ::krpc::schema::Service* Services::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Services.services)
  return services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Service >*
Services::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Services.services)
  return &services_;
}
inline const ::krpc::schema::Service& Services::_internal_services(int index) const {
  return services_.Get(index);
}
inline const ::krpc::schema::Service& Services::services(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Services.services)
  return _internal_services(index);
}
inline ::krpc::schema::Service* Services::_internal_add_services() {
  return services_.Add();
}
inline ::krpc::schema::Service* Services::add_services() {
  // @@protoc_insertion_point(field_add:krpc.schema.Services.services)
  return _internal_add_services();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Service >&
Services::services() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Services.services)
  return services_;
}

// -------------------------------------------------------------------

// Service

// string name = 1;
inline void Service::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.name)
  return _internal_name();
}
inline void Service::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Service.name)
}
inline std::string* Service::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.name)
  return _internal_mutable_name();
}
inline const std::string& Service::_internal_name() const {
  return name_.Get();
}
inline void Service::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Service::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Service.name)
}
inline void Service::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Service.name)
}
inline void Service::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Service.name)
}
inline std::string* Service::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Service::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Service.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Service::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Service.name)
}
inline std::string* Service::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Service.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Service::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Service.name)
}

// repeated .krpc.schema.Procedure procedures = 2;
inline int Service::_internal_procedures_size() const {
  return procedures_.size();
}
inline int Service::procedures_size() const {
  return _internal_procedures_size();
}
inline void Service::clear_procedures() {
  procedures_.Clear();
}
inline ::krpc::schema::Procedure* Service::mutable_procedures(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.procedures)
  return procedures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Procedure >*
Service::mutable_procedures() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.procedures)
  return &procedures_;
}
inline const ::krpc::schema::Procedure& Service::_internal_procedures(int index) const {
  return procedures_.Get(index);
}
inline const ::krpc::schema::Procedure& Service::procedures(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.procedures)
  return _internal_procedures(index);
}
inline ::krpc::schema::Procedure* Service::_internal_add_procedures() {
  return procedures_.Add();
}
inline ::krpc::schema::Procedure* Service::add_procedures() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.procedures)
  return _internal_add_procedures();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Procedure >&
Service::procedures() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.procedures)
  return procedures_;
}

// repeated .krpc.schema.Class classes = 3;
inline int Service::_internal_classes_size() const {
  return classes_.size();
}
inline int Service::classes_size() const {
  return _internal_classes_size();
}
inline void Service::clear_classes() {
  classes_.Clear();
}
inline ::krpc::schema::Class* Service::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.classes)
  return classes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Class >*
Service::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.classes)
  return &classes_;
}
inline const ::krpc::schema::Class& Service::_internal_classes(int index) const {
  return classes_.Get(index);
}
inline const ::krpc::schema::Class& Service::classes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.classes)
  return _internal_classes(index);
}
inline ::krpc::schema::Class* Service::_internal_add_classes() {
  return classes_.Add();
}
inline ::krpc::schema::Class* Service::add_classes() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.classes)
  return _internal_add_classes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Class >&
Service::classes() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.classes)
  return classes_;
}

// repeated .krpc.schema.Enumeration enumerations = 4;
inline int Service::_internal_enumerations_size() const {
  return enumerations_.size();
}
inline int Service::enumerations_size() const {
  return _internal_enumerations_size();
}
inline void Service::clear_enumerations() {
  enumerations_.Clear();
}
inline ::krpc::schema::Enumeration* Service::mutable_enumerations(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.enumerations)
  return enumerations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Enumeration >*
Service::mutable_enumerations() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.enumerations)
  return &enumerations_;
}
inline const ::krpc::schema::Enumeration& Service::_internal_enumerations(int index) const {
  return enumerations_.Get(index);
}
inline const ::krpc::schema::Enumeration& Service::enumerations(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.enumerations)
  return _internal_enumerations(index);
}
inline ::krpc::schema::Enumeration* Service::_internal_add_enumerations() {
  return enumerations_.Add();
}
inline ::krpc::schema::Enumeration* Service::add_enumerations() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.enumerations)
  return _internal_add_enumerations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Enumeration >&
Service::enumerations() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.enumerations)
  return enumerations_;
}

// repeated .krpc.schema.Exception exceptions = 5;
inline int Service::_internal_exceptions_size() const {
  return exceptions_.size();
}
inline int Service::exceptions_size() const {
  return _internal_exceptions_size();
}
inline void Service::clear_exceptions() {
  exceptions_.Clear();
}
inline ::krpc::schema::Exception* Service::mutable_exceptions(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.exceptions)
  return exceptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Exception >*
Service::mutable_exceptions() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Service.exceptions)
  return &exceptions_;
}
inline const ::krpc::schema::Exception& Service::_internal_exceptions(int index) const {
  return exceptions_.Get(index);
}
inline const ::krpc::schema::Exception& Service::exceptions(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.exceptions)
  return _internal_exceptions(index);
}
inline ::krpc::schema::Exception* Service::_internal_add_exceptions() {
  return exceptions_.Add();
}
inline ::krpc::schema::Exception* Service::add_exceptions() {
  // @@protoc_insertion_point(field_add:krpc.schema.Service.exceptions)
  return _internal_add_exceptions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Exception >&
Service::exceptions() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Service.exceptions)
  return exceptions_;
}

// string documentation = 6;
inline void Service::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Service::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Service.documentation)
  return _internal_documentation();
}
inline void Service::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Service.documentation)
}
inline std::string* Service::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Service.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& Service::_internal_documentation() const {
  return documentation_.Get();
}
inline void Service::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Service::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Service.documentation)
}
inline void Service::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Service.documentation)
}
inline void Service::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Service.documentation)
}
inline std::string* Service::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Service::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Service.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Service::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Service.documentation)
}
inline std::string* Service::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Service.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Service::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Service.documentation)
}

// -------------------------------------------------------------------

// Procedure

// string name = 1;
inline void Procedure::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Procedure::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.name)
  return _internal_name();
}
inline void Procedure::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.name)
}
inline std::string* Procedure::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.name)
  return _internal_mutable_name();
}
inline const std::string& Procedure::_internal_name() const {
  return name_.Get();
}
inline void Procedure::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Procedure::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Procedure.name)
}
inline void Procedure::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Procedure.name)
}
inline void Procedure::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Procedure.name)
}
inline std::string* Procedure::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Procedure::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Procedure::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.name)
}
inline std::string* Procedure::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Procedure.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Procedure::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Procedure.name)
}

// repeated .krpc.schema.Parameter parameters = 2;
inline int Procedure::_internal_parameters_size() const {
  return parameters_.size();
}
inline int Procedure::parameters_size() const {
  return _internal_parameters_size();
}
inline void Procedure::clear_parameters() {
  parameters_.Clear();
}
inline ::krpc::schema::Parameter* Procedure::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Parameter >*
Procedure::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Procedure.parameters)
  return &parameters_;
}
inline const ::krpc::schema::Parameter& Procedure::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::krpc::schema::Parameter& Procedure::parameters(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.parameters)
  return _internal_parameters(index);
}
inline ::krpc::schema::Parameter* Procedure::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::krpc::schema::Parameter* Procedure::add_parameters() {
  // @@protoc_insertion_point(field_add:krpc.schema.Procedure.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Parameter >&
Procedure::parameters() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Procedure.parameters)
  return parameters_;
}

// .krpc.schema.Type return_type = 3;
inline bool Procedure::_internal_has_return_type() const {
  return this != internal_default_instance() && return_type_ != nullptr;
}
inline bool Procedure::has_return_type() const {
  return _internal_has_return_type();
}
inline void Procedure::clear_return_type() {
  if (GetArena() == nullptr && return_type_ != nullptr) {
    delete return_type_;
  }
  return_type_ = nullptr;
}
inline const ::krpc::schema::Type& Procedure::_internal_return_type() const {
  const ::krpc::schema::Type* p = return_type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Type*>(
      &::krpc::schema::_Type_default_instance_);
}
inline const ::krpc::schema::Type& Procedure::return_type() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.return_type)
  return _internal_return_type();
}
inline void Procedure::unsafe_arena_set_allocated_return_type(
    ::krpc::schema::Type* return_type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(return_type_);
  }
  return_type_ = return_type;
  if (return_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Procedure.return_type)
}
inline ::krpc::schema::Type* Procedure::release_return_type() {
  auto temp = unsafe_arena_release_return_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Type* Procedure::unsafe_arena_release_return_type() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.return_type)
  
  ::krpc::schema::Type* temp = return_type_;
  return_type_ = nullptr;
  return temp;
}
inline ::krpc::schema::Type* Procedure::_internal_mutable_return_type() {
  
  if (return_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Type>(GetArena());
    return_type_ = p;
  }
  return return_type_;
}
inline ::krpc::schema::Type* Procedure::mutable_return_type() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.return_type)
  return _internal_mutable_return_type();
}
inline void Procedure::set_allocated_return_type(::krpc::schema::Type* return_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete return_type_;
  }
  if (return_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(return_type);
    if (message_arena != submessage_arena) {
      return_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, return_type, submessage_arena);
    }
    
  } else {
    
  }
  return_type_ = return_type;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.return_type)
}

// bool return_is_nullable = 4;
inline void Procedure::clear_return_is_nullable() {
  return_is_nullable_ = false;
}
inline bool Procedure::_internal_return_is_nullable() const {
  return return_is_nullable_;
}
inline bool Procedure::return_is_nullable() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.return_is_nullable)
  return _internal_return_is_nullable();
}
inline void Procedure::_internal_set_return_is_nullable(bool value) {
  
  return_is_nullable_ = value;
}
inline void Procedure::set_return_is_nullable(bool value) {
  _internal_set_return_is_nullable(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.return_is_nullable)
}

// repeated .krpc.schema.Procedure.GameScene game_scenes = 6;
inline int Procedure::_internal_game_scenes_size() const {
  return game_scenes_.size();
}
inline int Procedure::game_scenes_size() const {
  return _internal_game_scenes_size();
}
inline void Procedure::clear_game_scenes() {
  game_scenes_.Clear();
}
inline ::krpc::schema::Procedure_GameScene Procedure::_internal_game_scenes(int index) const {
  return static_cast< ::krpc::schema::Procedure_GameScene >(game_scenes_.Get(index));
}
inline ::krpc::schema::Procedure_GameScene Procedure::game_scenes(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.game_scenes)
  return _internal_game_scenes(index);
}
inline void Procedure::set_game_scenes(int index, ::krpc::schema::Procedure_GameScene value) {
  game_scenes_.Set(index, value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.game_scenes)
}
inline void Procedure::_internal_add_game_scenes(::krpc::schema::Procedure_GameScene value) {
  game_scenes_.Add(value);
}
inline void Procedure::add_game_scenes(::krpc::schema::Procedure_GameScene value) {
  // @@protoc_insertion_point(field_add:krpc.schema.Procedure.game_scenes)
  _internal_add_game_scenes(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Procedure::game_scenes() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Procedure.game_scenes)
  return game_scenes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Procedure::_internal_mutable_game_scenes() {
  return &game_scenes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Procedure::mutable_game_scenes() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Procedure.game_scenes)
  return _internal_mutable_game_scenes();
}

// string documentation = 5;
inline void Procedure::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Procedure::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Procedure.documentation)
  return _internal_documentation();
}
inline void Procedure::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Procedure.documentation)
}
inline std::string* Procedure::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Procedure.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& Procedure::_internal_documentation() const {
  return documentation_.Get();
}
inline void Procedure::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Procedure::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Procedure.documentation)
}
inline void Procedure::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Procedure.documentation)
}
inline void Procedure::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Procedure.documentation)
}
inline std::string* Procedure::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Procedure::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Procedure.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Procedure::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Procedure.documentation)
}
inline std::string* Procedure::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Procedure.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Procedure::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Procedure.documentation)
}

// -------------------------------------------------------------------

// Parameter

// string name = 1;
inline void Parameter::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.name)
  return _internal_name();
}
inline void Parameter::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Parameter.name)
}
inline std::string* Parameter::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.name)
  return _internal_mutable_name();
}
inline const std::string& Parameter::_internal_name() const {
  return name_.Get();
}
inline void Parameter::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Parameter::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Parameter.name)
}
inline void Parameter::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Parameter.name)
}
inline void Parameter::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Parameter.name)
}
inline std::string* Parameter::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Parameter::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Parameter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.name)
}
inline std::string* Parameter::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Parameter.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Parameter::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Parameter.name)
}

// .krpc.schema.Type type = 2;
inline bool Parameter::_internal_has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline bool Parameter::has_type() const {
  return _internal_has_type();
}
inline void Parameter::clear_type() {
  if (GetArena() == nullptr && type_ != nullptr) {
    delete type_;
  }
  type_ = nullptr;
}
inline const ::krpc::schema::Type& Parameter::_internal_type() const {
  const ::krpc::schema::Type* p = type_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Type*>(
      &::krpc::schema::_Type_default_instance_);
}
inline const ::krpc::schema::Type& Parameter::type() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.type)
  return _internal_type();
}
inline void Parameter::unsafe_arena_set_allocated_type(
    ::krpc::schema::Type* type) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(type_);
  }
  type_ = type;
  if (type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Parameter.type)
}
inline ::krpc::schema::Type* Parameter::release_type() {
  auto temp = unsafe_arena_release_type();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Type* Parameter::unsafe_arena_release_type() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.type)
  
  ::krpc::schema::Type* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::krpc::schema::Type* Parameter::_internal_mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Type>(GetArena());
    type_ = p;
  }
  return type_;
}
inline ::krpc::schema::Type* Parameter::mutable_type() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.type)
  return _internal_mutable_type();
}
inline void Parameter::set_allocated_type(::krpc::schema::Type* type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(type);
    if (message_arena != submessage_arena) {
      type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.type)
}

// bytes default_value = 3;
inline void Parameter::clear_default_value() {
  default_value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Parameter::default_value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Parameter.default_value)
  return _internal_default_value();
}
inline void Parameter::set_default_value(const std::string& value) {
  _internal_set_default_value(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Parameter.default_value)
}
inline std::string* Parameter::mutable_default_value() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Parameter.default_value)
  return _internal_mutable_default_value();
}
inline const std::string& Parameter::_internal_default_value() const {
  return default_value_.Get();
}
inline void Parameter::_internal_set_default_value(const std::string& value) {
  
  default_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Parameter::set_default_value(std::string&& value) {
  
  default_value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Parameter.default_value)
}
inline void Parameter::set_default_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  default_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Parameter.default_value)
}
inline void Parameter::set_default_value(const void* value,
    size_t size) {
  
  default_value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Parameter.default_value)
}
inline std::string* Parameter::_internal_mutable_default_value() {
  
  return default_value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Parameter::release_default_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.Parameter.default_value)
  return default_value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Parameter::set_allocated_default_value(std::string* default_value) {
  if (default_value != nullptr) {
    
  } else {
    
  }
  default_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Parameter.default_value)
}
inline std::string* Parameter::unsafe_arena_release_default_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Parameter.default_value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return default_value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Parameter::unsafe_arena_set_allocated_default_value(
    std::string* default_value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (default_value != nullptr) {
    
  } else {
    
  }
  default_value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      default_value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Parameter.default_value)
}

// -------------------------------------------------------------------

// Class

// string name = 1;
inline void Class::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Class::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Class.name)
  return _internal_name();
}
inline void Class::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Class.name)
}
inline std::string* Class::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Class.name)
  return _internal_mutable_name();
}
inline const std::string& Class::_internal_name() const {
  return name_.Get();
}
inline void Class::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Class::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Class.name)
}
inline void Class::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Class.name)
}
inline void Class::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Class.name)
}
inline std::string* Class::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Class::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Class.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Class::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Class.name)
}
inline std::string* Class::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Class.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Class::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Class.name)
}

// string documentation = 2;
inline void Class::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Class::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Class.documentation)
  return _internal_documentation();
}
inline void Class::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Class.documentation)
}
inline std::string* Class::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Class.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& Class::_internal_documentation() const {
  return documentation_.Get();
}
inline void Class::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Class::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Class.documentation)
}
inline void Class::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Class.documentation)
}
inline void Class::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Class.documentation)
}
inline std::string* Class::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Class::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Class.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Class::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Class.documentation)
}
inline std::string* Class::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Class.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Class::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Class.documentation)
}

// -------------------------------------------------------------------

// Enumeration

// string name = 1;
inline void Enumeration::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Enumeration::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.name)
  return _internal_name();
}
inline void Enumeration::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Enumeration.name)
}
inline std::string* Enumeration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.name)
  return _internal_mutable_name();
}
inline const std::string& Enumeration::_internal_name() const {
  return name_.Get();
}
inline void Enumeration::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Enumeration::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Enumeration.name)
}
inline void Enumeration::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Enumeration.name)
}
inline void Enumeration::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Enumeration.name)
}
inline std::string* Enumeration::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Enumeration::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Enumeration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Enumeration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Enumeration.name)
}
inline std::string* Enumeration::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Enumeration.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Enumeration::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Enumeration.name)
}

// repeated .krpc.schema.EnumerationValue values = 2;
inline int Enumeration::_internal_values_size() const {
  return values_.size();
}
inline int Enumeration::values_size() const {
  return _internal_values_size();
}
inline void Enumeration::clear_values() {
  values_.Clear();
}
inline ::krpc::schema::EnumerationValue* Enumeration::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::EnumerationValue >*
Enumeration::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Enumeration.values)
  return &values_;
}
inline const ::krpc::schema::EnumerationValue& Enumeration::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::krpc::schema::EnumerationValue& Enumeration::values(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.values)
  return _internal_values(index);
}
inline ::krpc::schema::EnumerationValue* Enumeration::_internal_add_values() {
  return values_.Add();
}
inline ::krpc::schema::EnumerationValue* Enumeration::add_values() {
  // @@protoc_insertion_point(field_add:krpc.schema.Enumeration.values)
  return _internal_add_values();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::EnumerationValue >&
Enumeration::values() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Enumeration.values)
  return values_;
}

// string documentation = 3;
inline void Enumeration::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Enumeration::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Enumeration.documentation)
  return _internal_documentation();
}
inline void Enumeration::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Enumeration.documentation)
}
inline std::string* Enumeration::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Enumeration.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& Enumeration::_internal_documentation() const {
  return documentation_.Get();
}
inline void Enumeration::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Enumeration::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Enumeration.documentation)
}
inline void Enumeration::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Enumeration.documentation)
}
inline void Enumeration::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Enumeration.documentation)
}
inline std::string* Enumeration::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Enumeration::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Enumeration.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Enumeration::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Enumeration.documentation)
}
inline std::string* Enumeration::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Enumeration.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Enumeration::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Enumeration.documentation)
}

// -------------------------------------------------------------------

// EnumerationValue

// string name = 1;
inline void EnumerationValue::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EnumerationValue::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.name)
  return _internal_name();
}
inline void EnumerationValue::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.name)
}
inline std::string* EnumerationValue::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.EnumerationValue.name)
  return _internal_mutable_name();
}
inline const std::string& EnumerationValue::_internal_name() const {
  return name_.Get();
}
inline void EnumerationValue::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EnumerationValue::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.EnumerationValue.name)
}
inline std::string* EnumerationValue::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EnumerationValue::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.EnumerationValue.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EnumerationValue::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.EnumerationValue.name)
}
inline std::string* EnumerationValue::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.EnumerationValue.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void EnumerationValue::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.EnumerationValue.name)
}

// int32 value = 2;
inline void EnumerationValue::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnumerationValue::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnumerationValue::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.value)
  return _internal_value();
}
inline void EnumerationValue::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void EnumerationValue::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.value)
}

// string documentation = 3;
inline void EnumerationValue::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EnumerationValue::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.EnumerationValue.documentation)
  return _internal_documentation();
}
inline void EnumerationValue::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.EnumerationValue.documentation)
}
inline std::string* EnumerationValue::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.EnumerationValue.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& EnumerationValue::_internal_documentation() const {
  return documentation_.Get();
}
inline void EnumerationValue::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EnumerationValue::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.EnumerationValue.documentation)
}
inline void EnumerationValue::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.EnumerationValue.documentation)
}
inline void EnumerationValue::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.EnumerationValue.documentation)
}
inline std::string* EnumerationValue::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EnumerationValue::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.EnumerationValue.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EnumerationValue::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.EnumerationValue.documentation)
}
inline std::string* EnumerationValue::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.EnumerationValue.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void EnumerationValue::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.EnumerationValue.documentation)
}

// -------------------------------------------------------------------

// Exception

// string name = 1;
inline void Exception::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Exception::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Exception.name)
  return _internal_name();
}
inline void Exception::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Exception.name)
}
inline std::string* Exception::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Exception.name)
  return _internal_mutable_name();
}
inline const std::string& Exception::_internal_name() const {
  return name_.Get();
}
inline void Exception::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Exception::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Exception.name)
}
inline void Exception::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Exception.name)
}
inline void Exception::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Exception.name)
}
inline std::string* Exception::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Exception::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Exception.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Exception::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Exception.name)
}
inline std::string* Exception::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Exception.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Exception::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Exception.name)
}

// string documentation = 2;
inline void Exception::clear_documentation() {
  documentation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Exception::documentation() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Exception.documentation)
  return _internal_documentation();
}
inline void Exception::set_documentation(const std::string& value) {
  _internal_set_documentation(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Exception.documentation)
}
inline std::string* Exception::mutable_documentation() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Exception.documentation)
  return _internal_mutable_documentation();
}
inline const std::string& Exception::_internal_documentation() const {
  return documentation_.Get();
}
inline void Exception::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Exception::set_documentation(std::string&& value) {
  
  documentation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Exception.documentation)
}
inline void Exception::set_documentation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Exception.documentation)
}
inline void Exception::set_documentation(const char* value,
    size_t size) {
  
  documentation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Exception.documentation)
}
inline std::string* Exception::_internal_mutable_documentation() {
  
  return documentation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Exception::release_documentation() {
  // @@protoc_insertion_point(field_release:krpc.schema.Exception.documentation)
  return documentation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Exception::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), documentation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Exception.documentation)
}
inline std::string* Exception::unsafe_arena_release_documentation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Exception.documentation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return documentation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Exception::unsafe_arena_set_allocated_documentation(
    std::string* documentation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      documentation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Exception.documentation)
}

// -------------------------------------------------------------------

// Type

// .krpc.schema.Type.TypeCode code = 1;
inline void Type::clear_code() {
  code_ = 0;
}
inline ::krpc::schema::Type_TypeCode Type::_internal_code() const {
  return static_cast< ::krpc::schema::Type_TypeCode >(code_);
}
inline ::krpc::schema::Type_TypeCode Type::code() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.code)
  return _internal_code();
}
inline void Type::_internal_set_code(::krpc::schema::Type_TypeCode value) {
  
  code_ = value;
}
inline void Type::set_code(::krpc::schema::Type_TypeCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Type.code)
}

// string service = 2;
inline void Type::clear_service() {
  service_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Type::service() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.service)
  return _internal_service();
}
inline void Type::set_service(const std::string& value) {
  _internal_set_service(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Type.service)
}
inline std::string* Type::mutable_service() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.service)
  return _internal_mutable_service();
}
inline const std::string& Type::_internal_service() const {
  return service_.Get();
}
inline void Type::_internal_set_service(const std::string& value) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Type::set_service(std::string&& value) {
  
  service_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Type.service)
}
inline void Type::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Type.service)
}
inline void Type::set_service(const char* value,
    size_t size) {
  
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Type.service)
}
inline std::string* Type::_internal_mutable_service() {
  
  return service_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Type::release_service() {
  // @@protoc_insertion_point(field_release:krpc.schema.Type.service)
  return service_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Type::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    
  } else {
    
  }
  service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Type.service)
}
inline std::string* Type::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Type.service)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return service_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Type::unsafe_arena_set_allocated_service(
    std::string* service) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (service != nullptr) {
    
  } else {
    
  }
  service_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      service, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Type.service)
}

// string name = 3;
inline void Type::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.name)
  return _internal_name();
}
inline void Type::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Type.name)
}
inline std::string* Type::mutable_name() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.name)
  return _internal_mutable_name();
}
inline const std::string& Type::_internal_name() const {
  return name_.Get();
}
inline void Type::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Type::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Type.name)
}
inline void Type::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Type.name)
}
inline void Type::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Type.name)
}
inline std::string* Type::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:krpc.schema.Type.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Type::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Type.name)
}
inline std::string* Type::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Type.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Type::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Type.name)
}

// repeated .krpc.schema.Type types = 4;
inline int Type::_internal_types_size() const {
  return types_.size();
}
inline int Type::types_size() const {
  return _internal_types_size();
}
inline void Type::clear_types() {
  types_.Clear();
}
inline ::krpc::schema::Type* Type::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Type.types)
  return types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Type >*
Type::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Type.types)
  return &types_;
}
inline const ::krpc::schema::Type& Type::_internal_types(int index) const {
  return types_.Get(index);
}
inline const ::krpc::schema::Type& Type::types(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Type.types)
  return _internal_types(index);
}
inline ::krpc::schema::Type* Type::_internal_add_types() {
  return types_.Add();
}
inline ::krpc::schema::Type* Type::add_types() {
  // @@protoc_insertion_point(field_add:krpc.schema.Type.types)
  return _internal_add_types();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::Type >&
Type::types() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Type.types)
  return types_;
}

// -------------------------------------------------------------------

// Tuple

// repeated bytes items = 1;
inline int Tuple::_internal_items_size() const {
  return items_.size();
}
inline int Tuple::items_size() const {
  return _internal_items_size();
}
inline void Tuple::clear_items() {
  items_.Clear();
}
inline std::string* Tuple::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.Tuple.items)
  return _internal_add_items();
}
inline const std::string& Tuple::_internal_items(int index) const {
  return items_.Get(index);
}
inline const std::string& Tuple::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Tuple.items)
  return _internal_items(index);
}
inline std::string* Tuple::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Tuple.items)
  return items_.Mutable(index);
}
inline void Tuple::set_items(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Tuple.items)
  items_.Mutable(index)->assign(value);
}
inline void Tuple::set_items(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Tuple.items)
  items_.Mutable(index)->assign(std::move(value));
}
inline void Tuple::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.Tuple.items)
}
inline void Tuple::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Tuple.items)
}
inline std::string* Tuple::_internal_add_items() {
  return items_.Add();
}
inline void Tuple::add_items(const std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.Tuple.items)
}
inline void Tuple::add_items(std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.Tuple.items)
}
inline void Tuple::add_items(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.Tuple.items)
}
inline void Tuple::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.Tuple.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Tuple::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Tuple.items)
  return items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Tuple::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Tuple.items)
  return &items_;
}

// -------------------------------------------------------------------

// List

// repeated bytes items = 1;
inline int List::_internal_items_size() const {
  return items_.size();
}
inline int List::items_size() const {
  return _internal_items_size();
}
inline void List::clear_items() {
  items_.Clear();
}
inline std::string* List::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.List.items)
  return _internal_add_items();
}
inline const std::string& List::_internal_items(int index) const {
  return items_.Get(index);
}
inline const std::string& List::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.List.items)
  return _internal_items(index);
}
inline std::string* List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.List.items)
  return items_.Mutable(index);
}
inline void List::set_items(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.List.items)
  items_.Mutable(index)->assign(value);
}
inline void List::set_items(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.List.items)
  items_.Mutable(index)->assign(std::move(value));
}
inline void List::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.List.items)
}
inline void List::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.List.items)
}
inline std::string* List::_internal_add_items() {
  return items_.Add();
}
inline void List::add_items(const std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.List.items)
}
inline void List::add_items(std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.List.items)
}
inline void List::add_items(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.List.items)
}
inline void List::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.List.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
List::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.List.items)
  return items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.List.items)
  return &items_;
}

// -------------------------------------------------------------------

// Set

// repeated bytes items = 1;
inline int Set::_internal_items_size() const {
  return items_.size();
}
inline int Set::items_size() const {
  return _internal_items_size();
}
inline void Set::clear_items() {
  items_.Clear();
}
inline std::string* Set::add_items() {
  // @@protoc_insertion_point(field_add_mutable:krpc.schema.Set.items)
  return _internal_add_items();
}
inline const std::string& Set::_internal_items(int index) const {
  return items_.Get(index);
}
inline const std::string& Set::items(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Set.items)
  return _internal_items(index);
}
inline std::string* Set::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Set.items)
  return items_.Mutable(index);
}
inline void Set::set_items(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Set.items)
  items_.Mutable(index)->assign(value);
}
inline void Set::set_items(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:krpc.schema.Set.items)
  items_.Mutable(index)->assign(std::move(value));
}
inline void Set::set_items(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:krpc.schema.Set.items)
}
inline void Set::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Set.items)
}
inline std::string* Set::_internal_add_items() {
  return items_.Add();
}
inline void Set::add_items(const std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:krpc.schema.Set.items)
}
inline void Set::add_items(std::string&& value) {
  items_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:krpc.schema.Set.items)
}
inline void Set::add_items(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:krpc.schema.Set.items)
}
inline void Set::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:krpc.schema.Set.items)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Set::items() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Set.items)
  return items_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Set::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Set.items)
  return &items_;
}

// -------------------------------------------------------------------

// Dictionary

// repeated .krpc.schema.DictionaryEntry entries = 1;
inline int Dictionary::_internal_entries_size() const {
  return entries_.size();
}
inline int Dictionary::entries_size() const {
  return _internal_entries_size();
}
inline void Dictionary::clear_entries() {
  entries_.Clear();
}
inline ::krpc::schema::DictionaryEntry* Dictionary::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Dictionary.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::DictionaryEntry >*
Dictionary::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:krpc.schema.Dictionary.entries)
  return &entries_;
}
inline const ::krpc::schema::DictionaryEntry& Dictionary::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::krpc::schema::DictionaryEntry& Dictionary::entries(int index) const {
  // @@protoc_insertion_point(field_get:krpc.schema.Dictionary.entries)
  return _internal_entries(index);
}
inline ::krpc::schema::DictionaryEntry* Dictionary::_internal_add_entries() {
  return entries_.Add();
}
inline ::krpc::schema::DictionaryEntry* Dictionary::add_entries() {
  // @@protoc_insertion_point(field_add:krpc.schema.Dictionary.entries)
  return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::krpc::schema::DictionaryEntry >&
Dictionary::entries() const {
  // @@protoc_insertion_point(field_list:krpc.schema.Dictionary.entries)
  return entries_;
}

// -------------------------------------------------------------------

// DictionaryEntry

// bytes key = 1;
inline void DictionaryEntry::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DictionaryEntry::key() const {
  // @@protoc_insertion_point(field_get:krpc.schema.DictionaryEntry.key)
  return _internal_key();
}
inline void DictionaryEntry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:krpc.schema.DictionaryEntry.key)
}
inline std::string* DictionaryEntry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.DictionaryEntry.key)
  return _internal_mutable_key();
}
inline const std::string& DictionaryEntry::_internal_key() const {
  return key_.Get();
}
inline void DictionaryEntry::_internal_set_key(const std::string& value) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DictionaryEntry::set_key(std::string&& value) {
  
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const void* value,
    size_t size) {
  
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.DictionaryEntry.key)
}
inline std::string* DictionaryEntry::_internal_mutable_key() {
  
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DictionaryEntry::release_key() {
  // @@protoc_insertion_point(field_release:krpc.schema.DictionaryEntry.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DictionaryEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.DictionaryEntry.key)
}
inline std::string* DictionaryEntry::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.DictionaryEntry.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DictionaryEntry::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    
  } else {
    
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.DictionaryEntry.key)
}

// bytes value = 2;
inline void DictionaryEntry::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DictionaryEntry::value() const {
  // @@protoc_insertion_point(field_get:krpc.schema.DictionaryEntry.value)
  return _internal_value();
}
inline void DictionaryEntry::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:krpc.schema.DictionaryEntry.value)
}
inline std::string* DictionaryEntry::mutable_value() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.DictionaryEntry.value)
  return _internal_mutable_value();
}
inline const std::string& DictionaryEntry::_internal_value() const {
  return value_.Get();
}
inline void DictionaryEntry::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DictionaryEntry::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const void* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.DictionaryEntry.value)
}
inline std::string* DictionaryEntry::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DictionaryEntry::release_value() {
  // @@protoc_insertion_point(field_release:krpc.schema.DictionaryEntry.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DictionaryEntry::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.DictionaryEntry.value)
}
inline std::string* DictionaryEntry::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.DictionaryEntry.value)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return value_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DictionaryEntry::unsafe_arena_set_allocated_value(
    std::string* value) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (value != nullptr) {
    
  } else {
    
  }
  value_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      value, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.DictionaryEntry.value)
}

// -------------------------------------------------------------------

// Stream

// uint64 id = 1;
inline void Stream::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Stream::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Stream::id() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Stream.id)
  return _internal_id();
}
inline void Stream::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  id_ = value;
}
inline void Stream::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Stream.id)
}

// -------------------------------------------------------------------

// Event

// .krpc.schema.Stream stream = 1;
inline bool Event::_internal_has_stream() const {
  return this != internal_default_instance() && stream_ != nullptr;
}
inline bool Event::has_stream() const {
  return _internal_has_stream();
}
inline void Event::clear_stream() {
  if (GetArena() == nullptr && stream_ != nullptr) {
    delete stream_;
  }
  stream_ = nullptr;
}
inline const ::krpc::schema::Stream& Event::_internal_stream() const {
  const ::krpc::schema::Stream* p = stream_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Stream*>(
      &::krpc::schema::_Stream_default_instance_);
}
inline const ::krpc::schema::Stream& Event::stream() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Event.stream)
  return _internal_stream();
}
inline void Event::unsafe_arena_set_allocated_stream(
    ::krpc::schema::Stream* stream) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_);
  }
  stream_ = stream;
  if (stream) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Event.stream)
}
inline ::krpc::schema::Stream* Event::release_stream() {
  auto temp = unsafe_arena_release_stream();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Stream* Event::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:krpc.schema.Event.stream)
  
  ::krpc::schema::Stream* temp = stream_;
  stream_ = nullptr;
  return temp;
}
inline ::krpc::schema::Stream* Event::_internal_mutable_stream() {
  
  if (stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Stream>(GetArena());
    stream_ = p;
  }
  return stream_;
}
inline ::krpc::schema::Stream* Event::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Event.stream)
  return _internal_mutable_stream();
}
inline void Event::set_allocated_stream(::krpc::schema::Stream* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Event.stream)
}

// -------------------------------------------------------------------

// Status

// string version = 1;
inline void Status::clear_version() {
  version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Status::version() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.version)
  return _internal_version();
}
inline void Status::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.version)
}
inline std::string* Status::mutable_version() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.Status.version)
  return _internal_mutable_version();
}
inline const std::string& Status::_internal_version() const {
  return version_.Get();
}
inline void Status::_internal_set_version(const std::string& value) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Status::set_version(std::string&& value) {
  
  version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:krpc.schema.Status.version)
}
inline void Status::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:krpc.schema.Status.version)
}
inline void Status::set_version(const char* value,
    size_t size) {
  
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:krpc.schema.Status.version)
}
inline std::string* Status::_internal_mutable_version() {
  
  return version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Status::release_version() {
  // @@protoc_insertion_point(field_release:krpc.schema.Status.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Status::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.Status.version)
}
inline std::string* Status::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:krpc.schema.Status.version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Status::unsafe_arena_set_allocated_version(
    std::string* version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version != nullptr) {
    
  } else {
    
  }
  version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.Status.version)
}

// uint64 bytes_read = 2;
inline void Status::clear_bytes_read() {
  bytes_read_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::_internal_bytes_read() const {
  return bytes_read_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::bytes_read() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_read)
  return _internal_bytes_read();
}
inline void Status::_internal_set_bytes_read(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_read_ = value;
}
inline void Status::set_bytes_read(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_read)
}

// uint64 bytes_written = 3;
inline void Status::clear_bytes_written() {
  bytes_written_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::_internal_bytes_written() const {
  return bytes_written_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::bytes_written() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_written)
  return _internal_bytes_written();
}
inline void Status::_internal_set_bytes_written(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  bytes_written_ = value;
}
inline void Status::set_bytes_written(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bytes_written(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_written)
}

// float bytes_read_rate = 4;
inline void Status::clear_bytes_read_rate() {
  bytes_read_rate_ = 0;
}
inline float Status::_internal_bytes_read_rate() const {
  return bytes_read_rate_;
}
inline float Status::bytes_read_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_read_rate)
  return _internal_bytes_read_rate();
}
inline void Status::_internal_set_bytes_read_rate(float value) {
  
  bytes_read_rate_ = value;
}
inline void Status::set_bytes_read_rate(float value) {
  _internal_set_bytes_read_rate(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_read_rate)
}

// float bytes_written_rate = 5;
inline void Status::clear_bytes_written_rate() {
  bytes_written_rate_ = 0;
}
inline float Status::_internal_bytes_written_rate() const {
  return bytes_written_rate_;
}
inline float Status::bytes_written_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.bytes_written_rate)
  return _internal_bytes_written_rate();
}
inline void Status::_internal_set_bytes_written_rate(float value) {
  
  bytes_written_rate_ = value;
}
inline void Status::set_bytes_written_rate(float value) {
  _internal_set_bytes_written_rate(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.bytes_written_rate)
}

// uint64 rpcs_executed = 6;
inline void Status::clear_rpcs_executed() {
  rpcs_executed_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::_internal_rpcs_executed() const {
  return rpcs_executed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::rpcs_executed() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.rpcs_executed)
  return _internal_rpcs_executed();
}
inline void Status::_internal_set_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  rpcs_executed_ = value;
}
inline void Status::set_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rpcs_executed(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.rpcs_executed)
}

// float rpc_rate = 7;
inline void Status::clear_rpc_rate() {
  rpc_rate_ = 0;
}
inline float Status::_internal_rpc_rate() const {
  return rpc_rate_;
}
inline float Status::rpc_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.rpc_rate)
  return _internal_rpc_rate();
}
inline void Status::_internal_set_rpc_rate(float value) {
  
  rpc_rate_ = value;
}
inline void Status::set_rpc_rate(float value) {
  _internal_set_rpc_rate(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.rpc_rate)
}

// bool one_rpc_per_update = 8;
inline void Status::clear_one_rpc_per_update() {
  one_rpc_per_update_ = false;
}
inline bool Status::_internal_one_rpc_per_update() const {
  return one_rpc_per_update_;
}
inline bool Status::one_rpc_per_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.one_rpc_per_update)
  return _internal_one_rpc_per_update();
}
inline void Status::_internal_set_one_rpc_per_update(bool value) {
  
  one_rpc_per_update_ = value;
}
inline void Status::set_one_rpc_per_update(bool value) {
  _internal_set_one_rpc_per_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.one_rpc_per_update)
}

// uint32 max_time_per_update = 9;
inline void Status::clear_max_time_per_update() {
  max_time_per_update_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::_internal_max_time_per_update() const {
  return max_time_per_update_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::max_time_per_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.max_time_per_update)
  return _internal_max_time_per_update();
}
inline void Status::_internal_set_max_time_per_update(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  max_time_per_update_ = value;
}
inline void Status::set_max_time_per_update(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_time_per_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.max_time_per_update)
}

// bool adaptive_rate_control = 10;
inline void Status::clear_adaptive_rate_control() {
  adaptive_rate_control_ = false;
}
inline bool Status::_internal_adaptive_rate_control() const {
  return adaptive_rate_control_;
}
inline bool Status::adaptive_rate_control() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.adaptive_rate_control)
  return _internal_adaptive_rate_control();
}
inline void Status::_internal_set_adaptive_rate_control(bool value) {
  
  adaptive_rate_control_ = value;
}
inline void Status::set_adaptive_rate_control(bool value) {
  _internal_set_adaptive_rate_control(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.adaptive_rate_control)
}

// bool blocking_recv = 11;
inline void Status::clear_blocking_recv() {
  blocking_recv_ = false;
}
inline bool Status::_internal_blocking_recv() const {
  return blocking_recv_;
}
inline bool Status::blocking_recv() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.blocking_recv)
  return _internal_blocking_recv();
}
inline void Status::_internal_set_blocking_recv(bool value) {
  
  blocking_recv_ = value;
}
inline void Status::set_blocking_recv(bool value) {
  _internal_set_blocking_recv(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.blocking_recv)
}

// uint32 recv_timeout = 12;
inline void Status::clear_recv_timeout() {
  recv_timeout_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::_internal_recv_timeout() const {
  return recv_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::recv_timeout() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.recv_timeout)
  return _internal_recv_timeout();
}
inline void Status::_internal_set_recv_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  recv_timeout_ = value;
}
inline void Status::set_recv_timeout(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_recv_timeout(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.recv_timeout)
}

// float time_per_rpc_update = 13;
inline void Status::clear_time_per_rpc_update() {
  time_per_rpc_update_ = 0;
}
inline float Status::_internal_time_per_rpc_update() const {
  return time_per_rpc_update_;
}
inline float Status::time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.time_per_rpc_update)
  return _internal_time_per_rpc_update();
}
inline void Status::_internal_set_time_per_rpc_update(float value) {
  
  time_per_rpc_update_ = value;
}
inline void Status::set_time_per_rpc_update(float value) {
  _internal_set_time_per_rpc_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.time_per_rpc_update)
}

// float poll_time_per_rpc_update = 14;
inline void Status::clear_poll_time_per_rpc_update() {
  poll_time_per_rpc_update_ = 0;
}
inline float Status::_internal_poll_time_per_rpc_update() const {
  return poll_time_per_rpc_update_;
}
inline float Status::poll_time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.poll_time_per_rpc_update)
  return _internal_poll_time_per_rpc_update();
}
inline void Status::_internal_set_poll_time_per_rpc_update(float value) {
  
  poll_time_per_rpc_update_ = value;
}
inline void Status::set_poll_time_per_rpc_update(float value) {
  _internal_set_poll_time_per_rpc_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.poll_time_per_rpc_update)
}

// float exec_time_per_rpc_update = 15;
inline void Status::clear_exec_time_per_rpc_update() {
  exec_time_per_rpc_update_ = 0;
}
inline float Status::_internal_exec_time_per_rpc_update() const {
  return exec_time_per_rpc_update_;
}
inline float Status::exec_time_per_rpc_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.exec_time_per_rpc_update)
  return _internal_exec_time_per_rpc_update();
}
inline void Status::_internal_set_exec_time_per_rpc_update(float value) {
  
  exec_time_per_rpc_update_ = value;
}
inline void Status::set_exec_time_per_rpc_update(float value) {
  _internal_set_exec_time_per_rpc_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.exec_time_per_rpc_update)
}

// uint32 stream_rpcs = 16;
inline void Status::clear_stream_rpcs() {
  stream_rpcs_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::_internal_stream_rpcs() const {
  return stream_rpcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Status::stream_rpcs() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpcs)
  return _internal_stream_rpcs();
}
inline void Status::_internal_set_stream_rpcs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  stream_rpcs_ = value;
}
inline void Status::set_stream_rpcs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_stream_rpcs(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpcs)
}

// uint64 stream_rpcs_executed = 17;
inline void Status::clear_stream_rpcs_executed() {
  stream_rpcs_executed_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::_internal_stream_rpcs_executed() const {
  return stream_rpcs_executed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::stream_rpcs_executed() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpcs_executed)
  return _internal_stream_rpcs_executed();
}
inline void Status::_internal_set_stream_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  stream_rpcs_executed_ = value;
}
inline void Status::set_stream_rpcs_executed(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_stream_rpcs_executed(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpcs_executed)
}

// float stream_rpc_rate = 18;
inline void Status::clear_stream_rpc_rate() {
  stream_rpc_rate_ = 0;
}
inline float Status::_internal_stream_rpc_rate() const {
  return stream_rpc_rate_;
}
inline float Status::stream_rpc_rate() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.stream_rpc_rate)
  return _internal_stream_rpc_rate();
}
inline void Status::_internal_set_stream_rpc_rate(float value) {
  
  stream_rpc_rate_ = value;
}
inline void Status::set_stream_rpc_rate(float value) {
  _internal_set_stream_rpc_rate(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.stream_rpc_rate)
}

// float time_per_stream_update = 19;
inline void Status::clear_time_per_stream_update() {
  time_per_stream_update_ = 0;
}
inline float Status::_internal_time_per_stream_update() const {
  return time_per_stream_update_;
}
inline float Status::time_per_stream_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.Status.time_per_stream_update)
  return _internal_time_per_stream_update();
}
inline void Status::_internal_set_time_per_stream_update(float value) {
  
  time_per_stream_update_ = value;
}
inline void Status::set_time_per_stream_update(float value) {
  _internal_set_time_per_stream_update(value);
  // @@protoc_insertion_point(field_set:krpc.schema.Status.time_per_stream_update)
}

// -------------------------------------------------------------------

// MultiplexedRequest

// .krpc.schema.ConnectionRequest connection_request = 1;
inline bool MultiplexedRequest::_internal_has_connection_request() const {
  return this != internal_default_instance() && connection_request_ != nullptr;
}
inline bool MultiplexedRequest::has_connection_request() const {
  return _internal_has_connection_request();
}
inline void MultiplexedRequest::clear_connection_request() {
  if (GetArena() == nullptr && connection_request_ != nullptr) {
    delete connection_request_;
  }
  connection_request_ = nullptr;
}
inline const ::krpc::schema::ConnectionRequest& MultiplexedRequest::_internal_connection_request() const {
  const ::krpc::schema::ConnectionRequest* p = connection_request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::ConnectionRequest*>(
      &::krpc::schema::_ConnectionRequest_default_instance_);
}
inline const ::krpc::schema::ConnectionRequest& MultiplexedRequest::connection_request() const {
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedRequest.connection_request)
  return _internal_connection_request();
}
inline void MultiplexedRequest::unsafe_arena_set_allocated_connection_request(
    ::krpc::schema::ConnectionRequest* connection_request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connection_request_);
  }
  connection_request_ = connection_request;
  if (connection_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.MultiplexedRequest.connection_request)
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::release_connection_request() {
  auto temp = unsafe_arena_release_connection_request();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::unsafe_arena_release_connection_request() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedRequest.connection_request)
  
  ::krpc::schema::ConnectionRequest* temp = connection_request_;
  connection_request_ = nullptr;
  return temp;
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::_internal_mutable_connection_request() {
  
  if (connection_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::ConnectionRequest>(GetArena());
    connection_request_ = p;
  }
  return connection_request_;
}
inline ::krpc::schema::ConnectionRequest* MultiplexedRequest::mutable_connection_request() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedRequest.connection_request)
  return _internal_mutable_connection_request();
}
inline void MultiplexedRequest::set_allocated_connection_request(::krpc::schema::ConnectionRequest* connection_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete connection_request_;
  }
  if (connection_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(connection_request);
    if (message_arena != submessage_arena) {
      connection_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connection_request, submessage_arena);
    }
    
  } else {
    
  }
  connection_request_ = connection_request;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedRequest.connection_request)
}

// .krpc.schema.Request request = 2;
inline bool MultiplexedRequest::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool MultiplexedRequest::has_request() const {
  return _internal_has_request();
}
inline void MultiplexedRequest::clear_request() {
  if (GetArena() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::krpc::schema::Request& MultiplexedRequest::_internal_request() const {
  const ::krpc::schema::Request* p = request_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Request*>(
      &::krpc::schema::_Request_default_instance_);
}
inline const ::krpc::schema::Request& MultiplexedRequest::request() const {
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedRequest.request)
  return _internal_request();
}
inline void MultiplexedRequest::unsafe_arena_set_allocated_request(
    ::krpc::schema::Request* request) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.MultiplexedRequest.request)
}
inline ::krpc::schema::Request* MultiplexedRequest::release_request() {
  auto temp = unsafe_arena_release_request();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Request* MultiplexedRequest::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedRequest.request)
  
  ::krpc::schema::Request* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::krpc::schema::Request* MultiplexedRequest::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Request>(GetArena());
    request_ = p;
  }
  return request_;
}
inline ::krpc::schema::Request* MultiplexedRequest::mutable_request() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedRequest.request)
  return _internal_mutable_request();
}
inline void MultiplexedRequest::set_allocated_request(::krpc::schema::Request* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedRequest.request)
}

// -------------------------------------------------------------------

// MultiplexedResponse

// .krpc.schema.Response response = 1;
inline bool MultiplexedResponse::_internal_has_response() const {
  return this != internal_default_instance() && response_ != nullptr;
}
inline bool MultiplexedResponse::has_response() const {
  return _internal_has_response();
}
inline void MultiplexedResponse::clear_response() {
  if (GetArena() == nullptr && response_ != nullptr) {
    delete response_;
  }
  response_ = nullptr;
}
inline const ::krpc::schema::Response& MultiplexedResponse::_internal_response() const {
  const ::krpc::schema::Response* p = response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::Response*>(
      &::krpc::schema::_Response_default_instance_);
}
inline const ::krpc::schema::Response& MultiplexedResponse::response() const {
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedResponse.response)
  return _internal_response();
}
inline void MultiplexedResponse::unsafe_arena_set_allocated_response(
    ::krpc::schema::Response* response) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(response_);
  }
  response_ = response;
  if (response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.MultiplexedResponse.response)
}
inline ::krpc::schema::Response* MultiplexedResponse::release_response() {
  auto temp = unsafe_arena_release_response();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::Response* MultiplexedResponse::unsafe_arena_release_response() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedResponse.response)
  
  ::krpc::schema::Response* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::krpc::schema::Response* MultiplexedResponse::_internal_mutable_response() {
  
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::Response>(GetArena());
    response_ = p;
  }
  return response_;
}
inline ::krpc::schema::Response* MultiplexedResponse::mutable_response() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedResponse.response)
  return _internal_mutable_response();
}
inline void MultiplexedResponse::set_allocated_response(::krpc::schema::Response* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(response);
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    
  } else {
    
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedResponse.response)
}

// .krpc.schema.StreamUpdate stream_update = 2;
inline bool MultiplexedResponse::_internal_has_stream_update() const {
  return this != internal_default_instance() && stream_update_ != nullptr;
}
inline bool MultiplexedResponse::has_stream_update() const {
  return _internal_has_stream_update();
}
inline void MultiplexedResponse::clear_stream_update() {
  if (GetArena() == nullptr && stream_update_ != nullptr) {
    delete stream_update_;
  }
  stream_update_ = nullptr;
}
inline const ::krpc::schema::StreamUpdate& MultiplexedResponse::_internal_stream_update() const {
  const ::krpc::schema::StreamUpdate* p = stream_update_;
  return p != nullptr ? *p : *reinterpret_cast<const ::krpc::schema::StreamUpdate*>(
      &::krpc::schema::_StreamUpdate_default_instance_);
}
inline const ::krpc::schema::StreamUpdate& MultiplexedResponse::stream_update() const {
  // @@protoc_insertion_point(field_get:krpc.schema.MultiplexedResponse.stream_update)
  return _internal_stream_update();
}
inline void MultiplexedResponse::unsafe_arena_set_allocated_stream_update(
    ::krpc::schema::StreamUpdate* stream_update) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_update_);
  }
  stream_update_ = stream_update;
  if (stream_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:krpc.schema.MultiplexedResponse.stream_update)
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::release_stream_update() {
  auto temp = unsafe_arena_release_stream_update();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::unsafe_arena_release_stream_update() {
  // @@protoc_insertion_point(field_release:krpc.schema.MultiplexedResponse.stream_update)
  
  ::krpc::schema::StreamUpdate* temp = stream_update_;
  stream_update_ = nullptr;
  return temp;
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::_internal_mutable_stream_update() {
  
  if (stream_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::krpc::schema::StreamUpdate>(GetArena());
    stream_update_ = p;
  }
  return stream_update_;
}
inline ::krpc::schema::StreamUpdate* MultiplexedResponse::mutable_stream_update() {
  // @@protoc_insertion_point(field_mutable:krpc.schema.MultiplexedResponse.stream_update)
  return _internal_mutable_stream_update();
}
inline void MultiplexedResponse::set_allocated_stream_update(::krpc::schema::StreamUpdate* stream_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete stream_update_;
  }
  if (stream_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(stream_update);
    if (message_arena != submessage_arena) {
      stream_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream_update, submessage_arena);
    }
    
  } else {
    
  }
  stream_update_ = stream_update;
  // @@protoc_insertion_point(field_set_allocated:krpc.schema.MultiplexedResponse.stream_update)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace schema
}  // namespace krpc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::krpc::schema::ConnectionRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::ConnectionRequest_Type>() {
  return ::krpc::schema::ConnectionRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::ConnectionResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::ConnectionResponse_Status>() {
  return ::krpc::schema::ConnectionResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::Procedure_GameScene> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::Procedure_GameScene>() {
  return ::krpc::schema::Procedure_GameScene_descriptor();
}
template <> struct is_proto_enum< ::krpc::schema::Type_TypeCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::krpc::schema::Type_TypeCode>() {
  return ::krpc::schema::Type_TypeCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_krpc_2eproto
